<!doctype html>
<html>
   <head>
      <meta charset="utf-8">
      <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
      <meta name="generator" content="pandoc">
      
      
      <title>1: A crash course in C++ and the standard library</title>
      <!-- Bootstrap -->
      <link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.5.0/css/bootstrap.min.css" integrity="sha384-9aIt2nRpC12Uk9gS9baDl411NQApFmC26EwAOH8WgZl5MYYxFfc+NcPb1dKGj7Sk" crossorigin="anonymous">
      <!-- Font-awesome -->
      <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css">
      <!-- Styles -->
      <link rel="stylesheet" href="style.css">
         </head>
   <body>
            <div class="container">
         <h1 class="title">1: A crash course in C++ and the standard library</h1>
                  <div class="row">
            <div class="col-xl-10"><p><a href="index.html">Back to top</a></p>
<h2 id="the-hello-world-program">The hello world program</h2>
<p>As is tradition in every computer science text, the book starts with a “hello world” program designed to highlight core behaviour of the language. Here’s the source, modified – per my own tradition – to print a slightly modified message:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true"></a><span class="co">// helloworld.cpp</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true"></a><span class="pp">#include </span><span class="im">&lt;iostream&gt;</span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true"></a></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true"></a><span class="dt">int</span> main() {</span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true"></a>    <span class="bu">std::</span>cout &lt;&lt; <span class="st">&quot;Hello cruel world&quot;</span> &lt;&lt; <span class="bu">std::</span>endl;</span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true"></a>    <span class="cf">return</span> <span class="dv">0</span>; </span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true"></a>}</span></code></pre></div>
<h2 id="compiling-helloworld.cpp">Compiling helloworld.cpp</h2>
<p>That’s all well and good, but I can’t do anything useful with this until I compile it, and for that to happen I need a C++ compiler. As it happens I already have g++ on my system, but – for no particular reason – I’ve decided to use clang. Installing clang on Ubuntu is pretty straightforward:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode bash"><code class="sourceCode bash"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true"></a><span class="fu">sudo</span> apt install clang</span></code></pre></div>
<p>Now that I have a compiler, I need to actually compile it. Here’s the command:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode bash"><code class="sourceCode bash"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true"></a><span class="fu">clang</span>++ --std=c++20 helloworld.cpp -o helloworld</span></code></pre></div>
<p>The <code>--std=c++20</code> flag tells clang what version of C++ I’m using, and the <code>-o</code> flag is used to specify the output file.</p>
<p>In practice, this isn’t the commmand I actually use. I don’t want my binaries to build into in the same folder as my source code, so I keep all the source code in <code>src</code> and the binaries in <code>bin</code>. So the command would actually look like this:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode bash"><code class="sourceCode bash"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true"></a><span class="fu">clang</span>++ --std=c++20 ./src/helloworld.cpp -o ./bin/helloworld</span></code></pre></div>
<p>As a side benefit, structuring the project this way makes it much easier to avoid accidentally commiting binary files to the git repository. All I have to do is add the <code>bin</code> folder to my <code>.gitignore</code> file. Fantastic.</p>
<p>That being said, I don’t actually want to type this command for every source file. Instead, because I’m a fundamentally lazy person, I’ve written a <code>Makefile</code> that takes care of that for me, and also renders the markdown files to html. So really the only command I ever use is simply:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode bash"><code class="sourceCode bash"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true"></a><span class="fu">make</span></span></code></pre></div>
<p>Anyway, once the source has been compiled, I can invoke the executable like so:</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode bash"><code class="sourceCode bash"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true"></a><span class="ex">./bin/helloworld</span></span></code></pre></div>
<p>And out pops the message at the terminal:</p>
<pre><code>Hello cruel world</code></pre>
<p>Excellent. The basics are working.</p>
<h2 id="notes-on-helloworld.cpp">Notes on helloworld.cpp</h2>
<p>Thankfully, I’ve written enough C++ code in the past that nothing about this surprises me. A few very basic syntactic notes in case I ever happen to share this with someone else coming from R.</p>
<ul>
<li>Comments in C++ are specified using <code>//</code></li>
<li>Lines must end with the semicolon <code>;</code></li>
<li>The <code>main()</code> function is special: that’s the entry point to your program. This is the function that gets called whenever you invoke the executable at the command line.</li>
<li>Unlike R, C++ is strongly typed, so when you define a function you must specify the output type: so in this case I write <code>int main() { // blah }</code> to specify that the output is an integer</li>
<li>C++ uses namespaces. In R you often see namespaces as package names (e.g., <code>dplyr::filter</code>), and <code>::</code> functions similarly here. When I write <code>std::cout</code>, I’m roughly saying “cout, which lives in the std namespace”.</li>
<li>The <code>#include</code> line is a “preprocessor directive”, used to specify meta-information about the program. In this case, it’s telling the preprocessor to take everything in the <code>&lt;iostream&gt;</code> header file and make it available to the program. Without it, I can’t do any input/output</li>
<li>In theory, since I’m notionally using C++20 in these notes, I could have written <code>import &lt;iostream&gt;;</code> instead of using the <code>#include</code> preprocessor directive. This is because C++20 introduced support for modules. I’m being a bit old-fashioned here, but for a good reason. When I installed clang with the command shown earlier, what I actually got on my system is clang version 14, and the support for modules in clang 14 is limited. I kind of don’t want to get bogged down with those details here, so I’m going to use <code>#include</code> directives instead of trying to get modules working.</li>
</ul>
<p>Going a little deeper:</p>
<ul>
<li><code>std::cout</code> refers to “standard out” (stdout), basically the place where we write output to the console. The metaphor used in the book is to think of it as a “chute” where you toss text.</li>
<li>The <code>&lt;&lt;</code> operator is used to “toss data into the chute”, so <code>std::cout &lt;&lt; "hello"</code> passes the text string <code>"hello"</code> to the standard output. As the helloworld program illustrates, you can concatenate multiple <code>&lt;&lt;</code> operations</li>
<li><code>std::endl</code> represents the end-of-line.</li>
</ul>
<p>If you don’t particularly want to namespace every command, as per <code>std::cout</code>, you can tell the compiler to make the names in a particular namespace available with a <code>using</code> directive (not dissimilar to calling <code>library()</code> in R). So I could have written my helloworld program like this:</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true"></a><span class="co">// helloworld-using.cpp</span></span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true"></a><span class="pp">#include </span><span class="im">&lt;iostream&gt;</span></span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true"></a></span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true"></a><span class="kw">using</span> <span class="kw">namespace</span> std;</span>
<span id="cb8-5"><a href="#cb8-5" aria-hidden="true"></a></span>
<span id="cb8-6"><a href="#cb8-6" aria-hidden="true"></a><span class="dt">int</span> main() {</span>
<span id="cb8-7"><a href="#cb8-7" aria-hidden="true"></a>    cout &lt;&lt; <span class="st">&quot;Hello cruel world&quot;</span> &lt;&lt; endl;</span>
<span id="cb8-8"><a href="#cb8-8" aria-hidden="true"></a>    <span class="cf">return</span> <span class="dv">0</span>; </span>
<span id="cb8-9"><a href="#cb8-9" aria-hidden="true"></a>}</span></code></pre></div>
<p>In general though it’s not a good idea because that leads to namespace conflicts pretty quickly.</p>
<h2 id="variables-types-and-operators">Variables, types, and operators</h2>
<p>The next part of the chapter walks you through variables, operators, types, and so on. Most of this feels very familiar and standard. Yes, C++ is strongly typed and requires variable declaration. This I know. I’ve gotten quite used to writing C++ code like this:</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true"></a><span class="co">// declares variables but does not initalise</span></span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true"></a><span class="dt">int</span> a;</span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true"></a><span class="dt">double</span> b;</span>
<span id="cb9-4"><a href="#cb9-4" aria-hidden="true"></a><span class="dt">bool</span> c;</span>
<span id="cb9-5"><a href="#cb9-5" aria-hidden="true"></a></span>
<span id="cb9-6"><a href="#cb9-6" aria-hidden="true"></a><span class="co">// declares and initialises variables</span></span>
<span id="cb9-7"><a href="#cb9-7" aria-hidden="true"></a><span class="co">// (this uses &quot;uniform initialisation&quot; syntax)</span></span>
<span id="cb9-8"><a href="#cb9-8" aria-hidden="true"></a><span class="dt">int</span> x = <span class="dv">2</span>;</span>
<span id="cb9-9"><a href="#cb9-9" aria-hidden="true"></a><span class="dt">double</span> y = <span class="fl">2.54</span>; </span>
<span id="cb9-10"><a href="#cb9-10" aria-hidden="true"></a><span class="dt">bool</span> z = <span class="kw">true</span>;</span></code></pre></div>
<p>Operators generally feel familiar from other languages. One thing I’ve missed while working in R is the increment and decrement operators, <code>++</code> and <code>--</code>. I have to admit I love these:</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true"></a><span class="co">// increment and decrement with + and -</span></span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true"></a>x = x + <span class="dv">1</span>;</span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true"></a>y = y - <span class="dv">1</span>;</span>
<span id="cb10-4"><a href="#cb10-4" aria-hidden="true"></a></span>
<span id="cb10-5"><a href="#cb10-5" aria-hidden="true"></a><span class="co">// this is the same</span></span>
<span id="cb10-6"><a href="#cb10-6" aria-hidden="true"></a>x++</span>
<span id="cb10-7"><a href="#cb10-7" aria-hidden="true"></a>y--</span></code></pre></div>
<h2 id="casting-and-coercion">Casting and coercion</h2>
<p>The nomenclature used in C++ when talking about changing variable types is a little more precise than it usually is in R. A <strong>cast</strong> is when you explicitly convert from one type to another. In contrast, the term <strong>coercion</strong> is used to describe an implicit cast.</p>
<p>The book gives this as example code. The idea being that you should be able to reason through the steps that the program is following, what cast operations are taking place, and thereby predict what it will print out at the end.</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true"></a><span class="co">// typecasting.cpp</span></span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true"></a><span class="pp">#include </span><span class="im">&lt;iostream&gt;</span></span>
<span id="cb11-3"><a href="#cb11-3" aria-hidden="true"></a></span>
<span id="cb11-4"><a href="#cb11-4" aria-hidden="true"></a><span class="dt">int</span> main() {</span>
<span id="cb11-5"><a href="#cb11-5" aria-hidden="true"></a>    <span class="co">// variable declarations</span></span>
<span id="cb11-6"><a href="#cb11-6" aria-hidden="true"></a>    <span class="dt">int</span> someInteger;</span>
<span id="cb11-7"><a href="#cb11-7" aria-hidden="true"></a>    <span class="dt">short</span> someShort;</span>
<span id="cb11-8"><a href="#cb11-8" aria-hidden="true"></a>    <span class="dt">long</span> someLong;</span>
<span id="cb11-9"><a href="#cb11-9" aria-hidden="true"></a>    <span class="dt">float</span> someFloat;</span>
<span id="cb11-10"><a href="#cb11-10" aria-hidden="true"></a>    <span class="dt">double</span> someDouble;</span>
<span id="cb11-11"><a href="#cb11-11" aria-hidden="true"></a></span>
<span id="cb11-12"><a href="#cb11-12" aria-hidden="true"></a>    <span class="co">// some operations that involve casts</span></span>
<span id="cb11-13"><a href="#cb11-13" aria-hidden="true"></a>    someInteger = <span class="dv">256</span>;</span>
<span id="cb11-14"><a href="#cb11-14" aria-hidden="true"></a>    someInteger++;</span>
<span id="cb11-15"><a href="#cb11-15" aria-hidden="true"></a>    someShort = <span class="kw">static_cast</span>&lt;<span class="dt">short</span>&gt;(someInteger);</span>
<span id="cb11-16"><a href="#cb11-16" aria-hidden="true"></a>    someLong = someShort * <span class="dv">10000</span>;</span>
<span id="cb11-17"><a href="#cb11-17" aria-hidden="true"></a>    someFloat = someLong + <span class="fl">0.785</span><span class="bu">f</span>;</span>
<span id="cb11-18"><a href="#cb11-18" aria-hidden="true"></a>    someDouble = <span class="kw">static_cast</span>&lt;<span class="dt">double</span>&gt;(someFloat) / <span class="dv">100000</span>;</span>
<span id="cb11-19"><a href="#cb11-19" aria-hidden="true"></a></span>
<span id="cb11-20"><a href="#cb11-20" aria-hidden="true"></a>    <span class="co">// print output and return</span></span>
<span id="cb11-21"><a href="#cb11-21" aria-hidden="true"></a>    <span class="bu">std::</span>cout &lt;&lt; someDouble &lt;&lt; <span class="bu">std::</span>endl;</span>
<span id="cb11-22"><a href="#cb11-22" aria-hidden="true"></a>    <span class="cf">return</span> <span class="dv">0</span>;</span>
<span id="cb11-23"><a href="#cb11-23" aria-hidden="true"></a>}</span></code></pre></div>
<p>Okay, I’ll give it a go. Stepping through it line by line…</p>
<ul>
<li>We start out with a signed 32 bit integer <code>someInteger</code> which has value 256.</li>
<li>The <code>++</code> operator increments this to 257.</li>
<li>We then use <code>static_cast()</code> to explicitly cast it to a signed 16 bit integer and store this as <code>someShort</code>.</li>
<li>In the next line we’re multiplying by 10000, which gives us an answer of 2570000. That’s too large a number to store as a 16 bit integer, but because the output variable <code>someLong</code> is typed as a long integer (also 32 bit), coercion takes place. The output is cast implicitly to long there’s an implicit cast happening here (called coercion), and the result is stored as a long integer with value 2570000.</li>
<li>The next line also involves coercion rather than an explicit cast. We’re adding a float (<code>0.785f</code>) to a long integer and storing the result as a float. So the output <code>someFloat</code> has value 2570000.785.</li>
<li>Finally, we explicitly cast <code>someFloat</code> to a double precision floating point number, divide it by 100000, and assign the result to <code>someDouble</code>. That gives us a value of 25.70000785</li>
</ul>
<p>We’ve lost a little precision in the printed output, however, because the program prints 25.7 to stdout.</p>
<h2 id="enumerated-types">Enumerated types</h2>
<p>Next up: “strongly typed enumerated types”. <strong>Enumerated types</strong> are essentially the C++ version of R factors, or Python dictionaries I guess. The key idea is to have a discrete set of labelled values. Internally the objects are encoded as integer values, but those numbers are masked so you can’t do silly things with them. So, for example I could encode gender (somewhat crudely) with an enumerated type as follows:</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true"></a><span class="kw">enum</span> <span class="kw">class</span> Gender { male, female, nonbinary, other, unspecified };</span></code></pre></div>
<p>To declare and initialise some gender variables I would do this:</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true"></a><span class="kw">enum</span> <span class="kw">class</span> Gender { male, female, nonbinary, other, unspecified };</span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true"></a>Gender danielle_gender { Gender::female };</span>
<span id="cb13-3"><a href="#cb13-3" aria-hidden="true"></a>Gender benjamin_gender { Gender::male };</span></code></pre></div>
<p>The internal coding is revealed by this program:</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true"></a><span class="co">// enumerated-types.cpp</span></span>
<span id="cb14-2"><a href="#cb14-2" aria-hidden="true"></a><span class="pp">#include </span><span class="im">&lt;iostream&gt;</span></span>
<span id="cb14-3"><a href="#cb14-3" aria-hidden="true"></a></span>
<span id="cb14-4"><a href="#cb14-4" aria-hidden="true"></a><span class="dt">int</span> main() {</span>
<span id="cb14-5"><a href="#cb14-5" aria-hidden="true"></a>    <span class="kw">enum</span> <span class="kw">class</span> Gender { male, female, nonbinary, other, unspecified };</span>
<span id="cb14-6"><a href="#cb14-6" aria-hidden="true"></a>    Gender danielle_gender { Gender::female };</span>
<span id="cb14-7"><a href="#cb14-7" aria-hidden="true"></a>    Gender benjamin_gender { Gender::male };</span>
<span id="cb14-8"><a href="#cb14-8" aria-hidden="true"></a></span>
<span id="cb14-9"><a href="#cb14-9" aria-hidden="true"></a>    <span class="bu">std::</span>cout &lt;&lt; <span class="st">&quot;Danielle gender: &quot;</span> &lt;&lt; <span class="kw">static_cast</span>&lt;<span class="dt">int</span>&gt;(danielle_gender) &lt;&lt; <span class="bu">std::</span>endl;</span>
<span id="cb14-10"><a href="#cb14-10" aria-hidden="true"></a>    <span class="bu">std::</span>cout &lt;&lt; <span class="st">&quot;Benjamin gender: &quot;</span> &lt;&lt; <span class="kw">static_cast</span>&lt;<span class="dt">int</span>&gt;(benjamin_gender) &lt;&lt; <span class="bu">std::</span>endl;</span>
<span id="cb14-11"><a href="#cb14-11" aria-hidden="true"></a>    <span class="cf">return</span> <span class="dv">0</span>; </span>
<span id="cb14-12"><a href="#cb14-12" aria-hidden="true"></a>}</span></code></pre></div>
<p>When we run this one, the output looks like this:</p>
<pre><code>Danielle gender: 1
Benjamin gender: 0</code></pre>
<h2 id="structs">Structs</h2>
<p>Moving along. The next kind of objects the book considers are <strong>structs</strong>, which allow you to group one or more existing objects (which may themselves be of different types) into a new type. They are, more or less, the C++ analog of lists in R.</p>
<p>It’s not uncommon for C++ code to define a class within a header file which can be made available to the program by an <code>#include</code> directive (or, in C++20, imported as a module). Sticking reasonably closely to what is in the book here, I’ll write a header file that defines an <code>Employee</code> class:</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true"></a><span class="co">// employee.h</span></span>
<span id="cb16-2"><a href="#cb16-2" aria-hidden="true"></a><span class="kw">struct</span> Employee {</span>
<span id="cb16-3"><a href="#cb16-3" aria-hidden="true"></a>    <span class="dt">char</span> firstInitial;</span>
<span id="cb16-4"><a href="#cb16-4" aria-hidden="true"></a>    <span class="dt">char</span> lastInitial;</span>
<span id="cb16-5"><a href="#cb16-5" aria-hidden="true"></a>    <span class="dt">int</span> employeeNumber;</span>
<span id="cb16-6"><a href="#cb16-6" aria-hidden="true"></a>    <span class="dt">int</span> salary;</span>
<span id="cb16-7"><a href="#cb16-7" aria-hidden="true"></a>};</span></code></pre></div>
<p>In the book, the code is a little more elaborate because it explicitly defines a module, but since my compiler has incomplete support for C++20 features, I’m keeping it simple.</p>
<p>A thing to note here is that C++ doesn’t supply a string type out of the box, which is – I would imagine – the reason why this class sidesteps that awkwardness and encodes only the <code>firstInitial</code> and <code>lastInitial</code> as fields in an <code>Employee</code> struct. By doing that we can get away with using a char here. There are of course ways to specify strings, but it’s a bit tangential to the discussion.</p>
<p>Anyway, the key thing is that we access the fields of a struct using <code>.</code> as the code below illustrates:</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true"></a>Employee danielle;</span>
<span id="cb17-2"><a href="#cb17-2" aria-hidden="true"></a>danielle.firstInitial = <span class="ch">&#39;D&#39;</span>;</span>
<span id="cb17-3"><a href="#cb17-3" aria-hidden="true"></a>danielle.lastInitial = <span class="ch">&#39;N&#39;</span>;</span>
<span id="cb17-4"><a href="#cb17-4" aria-hidden="true"></a>danielle.employeeNumber = <span class="dv">69</span>;</span>
<span id="cb17-5"><a href="#cb17-5" aria-hidden="true"></a>danielle.salary = <span class="dv">123456</span>;</span></code></pre></div>
<p>To see it in action we can write a short program. Again we have a bit of an issue because the book uses C++20 features that my compiler doesn’t support. Specifically, it uses the new C++20 <code>&lt;format&gt;</code> module to handle printing, which I don’t have access to. Rather than mess about with compilers to get the new hotness working or introduce an external dependency, I decided to use stringstream objects provided by the <code>&lt;sstream&gt;</code> header file.</p>
<p>So my program looks like this:</p>
<div class="sourceCode" id="cb18"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb18-1"><a href="#cb18-1" aria-hidden="true"></a><span class="co">// employee.cpp</span></span>
<span id="cb18-2"><a href="#cb18-2" aria-hidden="true"></a><span class="pp">#include </span><span class="im">&lt;iostream&gt;</span></span>
<span id="cb18-3"><a href="#cb18-3" aria-hidden="true"></a><span class="pp">#include </span><span class="im">&lt;sstream&gt;</span></span>
<span id="cb18-4"><a href="#cb18-4" aria-hidden="true"></a><span class="pp">#include </span><span class="im">&quot;employee.h&quot;</span></span>
<span id="cb18-5"><a href="#cb18-5" aria-hidden="true"></a></span>
<span id="cb18-6"><a href="#cb18-6" aria-hidden="true"></a><span class="dt">int</span> main() {</span>
<span id="cb18-7"><a href="#cb18-7" aria-hidden="true"></a>    <span class="co">// define the employee record</span></span>
<span id="cb18-8"><a href="#cb18-8" aria-hidden="true"></a>    Employee danielle;</span>
<span id="cb18-9"><a href="#cb18-9" aria-hidden="true"></a>    danielle.firstInitial = <span class="ch">&#39;D&#39;</span>;</span>
<span id="cb18-10"><a href="#cb18-10" aria-hidden="true"></a>    danielle.lastInitial = <span class="ch">&#39;N&#39;</span>;</span>
<span id="cb18-11"><a href="#cb18-11" aria-hidden="true"></a>    danielle.employeeNumber = <span class="dv">69</span>;</span>
<span id="cb18-12"><a href="#cb18-12" aria-hidden="true"></a>    danielle.salary = <span class="dv">123456</span>;</span>
<span id="cb18-13"><a href="#cb18-13" aria-hidden="true"></a></span>
<span id="cb18-14"><a href="#cb18-14" aria-hidden="true"></a>    <span class="co">// write to stdout</span></span>
<span id="cb18-15"><a href="#cb18-15" aria-hidden="true"></a>    <span class="bu">std::</span>stringstream ss;</span>
<span id="cb18-16"><a href="#cb18-16" aria-hidden="true"></a>    ss.str(<span class="st">&quot;&quot;</span>);</span>
<span id="cb18-17"><a href="#cb18-17" aria-hidden="true"></a>    ss &lt;&lt; <span class="st">&quot;Employee: &quot;</span> &lt;&lt; danielle.firstInitial &lt;&lt; danielle.lastInitial;</span>
<span id="cb18-18"><a href="#cb18-18" aria-hidden="true"></a>    <span class="bu">std::</span>cout &lt;&lt; ss.str() &lt;&lt; <span class="bu">std::</span>endl;</span>
<span id="cb18-19"><a href="#cb18-19" aria-hidden="true"></a></span>
<span id="cb18-20"><a href="#cb18-20" aria-hidden="true"></a>    ss.str(<span class="st">&quot;&quot;</span>);</span>
<span id="cb18-21"><a href="#cb18-21" aria-hidden="true"></a>    ss &lt;&lt; <span class="st">&quot;Employee number: #&quot;</span> &lt;&lt; danielle.employeeNumber;</span>
<span id="cb18-22"><a href="#cb18-22" aria-hidden="true"></a>    <span class="bu">std::</span>cout &lt;&lt; ss.str() &lt;&lt; <span class="bu">std::</span>endl;</span>
<span id="cb18-23"><a href="#cb18-23" aria-hidden="true"></a></span>
<span id="cb18-24"><a href="#cb18-24" aria-hidden="true"></a>    ss.str(<span class="st">&quot;&quot;</span>);</span>
<span id="cb18-25"><a href="#cb18-25" aria-hidden="true"></a>    ss &lt;&lt; <span class="st">&quot;Employee salary: $&quot;</span> &lt;&lt; danielle.salary;</span>
<span id="cb18-26"><a href="#cb18-26" aria-hidden="true"></a>    <span class="bu">std::</span>cout &lt;&lt; ss.str() &lt;&lt; <span class="bu">std::</span>endl;</span>
<span id="cb18-27"><a href="#cb18-27" aria-hidden="true"></a></span>
<span id="cb18-28"><a href="#cb18-28" aria-hidden="true"></a>    <span class="cf">return</span> <span class="dv">0</span>;</span>
<span id="cb18-29"><a href="#cb18-29" aria-hidden="true"></a>}</span></code></pre></div>
<p>When I run this program I get this as output:</p>
<pre><code>Employee: DN
Employee number: #69
Employee salary: $123456</code></pre>
<p>That all seems to make sense. What’s next?</p>
<h2 id="digression-poisson-variates">Digression: Poisson variates</h2>
<p>Looking ahead, it seems like the book is about to start discussing conditional branching, functions, loops, and all that good stuff. Fair enough. But conditional branching based on testing some boolean expression is never much fun unless you have a something meaningful to test. Ideally you’d have something where the conditional might evaluate differently. So, since we’re all statisticians here (I mean, it’s just me here and I’m a statistician), this feels like a good moment to divert from the text and write some code that generates Poisson random numbers. To do this I’ll use <code>&lt;random&gt;</code>:</p>
<div class="sourceCode" id="cb20"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb20-1"><a href="#cb20-1" aria-hidden="true"></a><span class="co">// poisson-sample.cpp</span></span>
<span id="cb20-2"><a href="#cb20-2" aria-hidden="true"></a><span class="pp">#include </span><span class="im">&lt;iostream&gt;</span></span>
<span id="cb20-3"><a href="#cb20-3" aria-hidden="true"></a><span class="pp">#include </span><span class="im">&lt;random&gt;</span></span>
<span id="cb20-4"><a href="#cb20-4" aria-hidden="true"></a></span>
<span id="cb20-5"><a href="#cb20-5" aria-hidden="true"></a><span class="dt">int</span> main() {</span>
<span id="cb20-6"><a href="#cb20-6" aria-hidden="true"></a>    <span class="co">// set seed using time, define PRNG with Mersenne Twister</span></span>
<span id="cb20-7"><a href="#cb20-7" aria-hidden="true"></a>    <span class="dt">long</span> <span class="dt">unsigned</span> <span class="dt">int</span> seed = <span class="kw">static_cast</span>&lt;<span class="dt">long</span> <span class="dt">unsigned</span> <span class="dt">int</span>&gt;(time(<span class="dv">0</span>));</span>
<span id="cb20-8"><a href="#cb20-8" aria-hidden="true"></a>    <span class="bu">std::</span>mt19937_64 mersenne {seed};</span>
<span id="cb20-9"><a href="#cb20-9" aria-hidden="true"></a></span>
<span id="cb20-10"><a href="#cb20-10" aria-hidden="true"></a>    <span class="co">// sample_poisson() draws from Poisson(4.1) and returns an integer.</span></span>
<span id="cb20-11"><a href="#cb20-11" aria-hidden="true"></a>    <span class="bu">std::</span>poisson_distribution&lt;<span class="dt">int</span>&gt; sample_poisson(<span class="fl">4.1</span>);</span>
<span id="cb20-12"><a href="#cb20-12" aria-hidden="true"></a></span>
<span id="cb20-13"><a href="#cb20-13" aria-hidden="true"></a>    <span class="co">// draw poisson sample (passing the PRNG as argument) and write to stdout</span></span>
<span id="cb20-14"><a href="#cb20-14" aria-hidden="true"></a>    <span class="bu">std::</span>cout &lt;&lt; <span class="st">&quot;poisson sample: &quot;</span> &lt;&lt; sample_poisson(mersenne) &lt;&lt; <span class="bu">std::</span>endl;</span>
<span id="cb20-15"><a href="#cb20-15" aria-hidden="true"></a>    <span class="cf">return</span> <span class="dv">0</span>;</span>
<span id="cb20-16"><a href="#cb20-16" aria-hidden="true"></a>}</span></code></pre></div>
<p>Here’s what happens when I repeatedly invoke the <code>sample-poisson</code> program at the terminal:</p>
<pre><code>poisson sample: 2
poisson sample: 6
poisson sample: 2
poisson sample: 5
poisson sample: 2
poisson sample: 4
poisson sample: 4</code></pre>
<p>You get the idea.</p>
<h2 id="conditionals">Conditionals</h2>
<p>Okay, back to the development of ideas in the book. Next up is conditional branching, and the basic syntax is deeply familiar to anyone who has programmed in… pretty much any language I guess. The first example in the book shows a cascading if statement like this:</p>
<div class="sourceCode" id="cb22"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb22-1"><a href="#cb22-1" aria-hidden="true"></a><span class="cf">if</span> (value &gt; <span class="dv">4</span>) {</span>
<span id="cb22-2"><a href="#cb22-2" aria-hidden="true"></a>    <span class="co">// do something</span></span>
<span id="cb22-3"><a href="#cb22-3" aria-hidden="true"></a>} <span class="cf">else</span> <span class="cf">if</span> (value &gt; <span class="dv">2</span>) {</span>
<span id="cb22-4"><a href="#cb22-4" aria-hidden="true"></a>    <span class="co">// do something else</span></span>
<span id="cb22-5"><a href="#cb22-5" aria-hidden="true"></a>} <span class="cf">else</span> {</span>
<span id="cb22-6"><a href="#cb22-6" aria-hidden="true"></a>    <span class="co">// do something else</span></span>
<span id="cb22-7"><a href="#cb22-7" aria-hidden="true"></a>}</span></code></pre></div>
<p>However, the nice thing about having some code to sample random numbers is that I can write something a little less boring here. Here’s a small program that samples a Poisson random variate, and prints a message to the terminal that adds a little comment about where the sample falls relative to the distribution mode:</p>
<div class="sourceCode" id="cb23"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb23-1"><a href="#cb23-1" aria-hidden="true"></a><span class="co">// poisson-conditional.cpp</span></span>
<span id="cb23-2"><a href="#cb23-2" aria-hidden="true"></a><span class="pp">#include </span><span class="im">&lt;iostream&gt;</span></span>
<span id="cb23-3"><a href="#cb23-3" aria-hidden="true"></a><span class="pp">#include </span><span class="im">&lt;random&gt;</span></span>
<span id="cb23-4"><a href="#cb23-4" aria-hidden="true"></a></span>
<span id="cb23-5"><a href="#cb23-5" aria-hidden="true"></a><span class="dt">int</span> main() {</span>
<span id="cb23-6"><a href="#cb23-6" aria-hidden="true"></a>    <span class="co">// sample an integer value from a poisson distribution</span></span>
<span id="cb23-7"><a href="#cb23-7" aria-hidden="true"></a>    <span class="dt">long</span> <span class="dt">unsigned</span> <span class="dt">int</span> seed = <span class="kw">static_cast</span>&lt;<span class="dt">long</span> <span class="dt">unsigned</span> <span class="dt">int</span>&gt;(time(<span class="dv">0</span>));</span>
<span id="cb23-8"><a href="#cb23-8" aria-hidden="true"></a>    <span class="bu">std::</span>mt19937_64 mersenne {seed};</span>
<span id="cb23-9"><a href="#cb23-9" aria-hidden="true"></a>    <span class="bu">std::</span>poisson_distribution&lt;<span class="dt">int</span>&gt; sample_poisson(<span class="fl">4.1</span>);</span>
<span id="cb23-10"><a href="#cb23-10" aria-hidden="true"></a></span>
<span id="cb23-11"><a href="#cb23-11" aria-hidden="true"></a>    <span class="co">// sample a value and write first part of message</span></span>
<span id="cb23-12"><a href="#cb23-12" aria-hidden="true"></a>    <span class="dt">int</span> value = sample_poisson(mersenne);</span>
<span id="cb23-13"><a href="#cb23-13" aria-hidden="true"></a>    <span class="bu">std::</span>cout &lt;&lt; <span class="st">&quot;The sampled value of &quot;</span> &lt;&lt; value;</span>
<span id="cb23-14"><a href="#cb23-14" aria-hidden="true"></a></span>
<span id="cb23-15"><a href="#cb23-15" aria-hidden="true"></a>    <span class="co">// remainder of message depends on the value</span></span>
<span id="cb23-16"><a href="#cb23-16" aria-hidden="true"></a>    <span class="cf">if</span> (value == <span class="dv">4</span>) {</span>
<span id="cb23-17"><a href="#cb23-17" aria-hidden="true"></a>        <span class="bu">std::</span>cout &lt;&lt; <span class="st">&quot; is the modal value.&quot;</span> &lt;&lt; <span class="bu">std::</span>endl;</span>
<span id="cb23-18"><a href="#cb23-18" aria-hidden="true"></a>    } <span class="cf">else</span> <span class="cf">if</span> (value &lt; <span class="dv">4</span>) {</span>
<span id="cb23-19"><a href="#cb23-19" aria-hidden="true"></a>        <span class="bu">std::</span>cout &lt;&lt; <span class="st">&quot; is below the mode.&quot;</span> &lt;&lt; <span class="bu">std::</span>endl;</span>
<span id="cb23-20"><a href="#cb23-20" aria-hidden="true"></a>    } <span class="cf">else</span> {</span>
<span id="cb23-21"><a href="#cb23-21" aria-hidden="true"></a>        <span class="bu">std::</span>cout &lt;&lt; <span class="st">&quot; is above the mode.&quot;</span> &lt;&lt; <span class="bu">std::</span>endl;</span>
<span id="cb23-22"><a href="#cb23-22" aria-hidden="true"></a>    }</span>
<span id="cb23-23"><a href="#cb23-23" aria-hidden="true"></a>    <span class="cf">return</span> <span class="dv">0</span>;</span>
<span id="cb23-24"><a href="#cb23-24" aria-hidden="true"></a>}</span></code></pre></div>
<p>Again, here’s some output I get when I repeatedly invoke the <code>poisson-conditional</code> function:</p>
<pre><code>The sampled value of 11 is above the mode.
The sampled value of 4 is the modal value.
The sampled value of 6 is above the mode.
The sampled value of 5 is above the mode.
The sampled value of 4 is the modal value.
The sampled value of 3 is below the mode.</code></pre>
<p>Exciting times in the life of Danielle.</p></div>
            <div class="d-none d-xl-block col-xl-2 bd-toc">
               <ul class="section-nav">
                  <li class="toc-entry"><ul>
<li><a href="#the-hello-world-program">The hello world program</a></li>
<li><a href="#compiling-helloworld.cpp">Compiling helloworld.cpp</a></li>
<li><a href="#notes-on-helloworld.cpp">Notes on helloworld.cpp</a></li>
<li><a href="#variables-types-and-operators">Variables, types, and operators</a></li>
<li><a href="#casting-and-coercion">Casting and coercion</a></li>
<li><a href="#enumerated-types">Enumerated types</a></li>
<li><a href="#structs">Structs</a></li>
<li><a href="#digression-poisson-variates">Digression: Poisson variates</a></li>
<li><a href="#conditionals">Conditionals</a></li>
</ul></li>
               </ul>
            </div>
         </div>
               </div>
            <!-- JS, Popper.js, and jQuery -->
      <script src="https://code.jquery.com/jquery-3.5.1.slim.min.js" integrity="sha384-DfXdz2htPH0lsSSs5nCTpuj/zy4C+OGpamoFVy38MVBnE+IbbVYUew+OrCXaRkfj" crossorigin="anonymous"></script>
      <script src="https://cdn.jsdelivr.net/npm/popper.js@1.16.0/dist/umd/popper.min.js" integrity="sha384-Q6E9RHvbIyZFJoft+2mJbHaEWldlvI9IOYy5n3zV9zzTtmI3UksdQRVvoxMfooAo" crossorigin="anonymous"></script>
      <script src="https://stackpath.bootstrapcdn.com/bootstrap/4.5.0/js/bootstrap.min.js" integrity="sha384-OgVRvuATP1z7JjHLkuOU7Xw704+h835Lr+6QL9UvYjZE3Ipu6Tp75j7Bh/kR0JKI" crossorigin="anonymous"></script>
      <!-- Mathjax -->
      <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
      <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
      <script>
         /* Bootstrap styles to tables */
         function bootstrapStylePandocTables() {
         $('tr.header').parent('thead').parent('table').addClass('table table-condensed'); }
         $(document).ready(function () { bootstrapStylePandocTables(); });
         /* Adjust the height when click the toc */
         var shiftWindow = function() { scrollBy(0, -60) };
         window.addEventListener("hashchange", shiftWindow);
         function load() { if (window.location.hash) shiftWindow(); }
      </script>
   </body>
</html>
