<!doctype html>
<html>
   <head>
      <meta charset="utf-8">
      <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
      <meta name="generator" content="pandoc">
      
      
      <title>1: A crash course in C++ and the standard library</title>
      <!-- Bootstrap -->
      <link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.5.0/css/bootstrap.min.css" integrity="sha384-9aIt2nRpC12Uk9gS9baDl411NQApFmC26EwAOH8WgZl5MYYxFfc+NcPb1dKGj7Sk" crossorigin="anonymous">
      <!-- Font-awesome -->
      <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css">
      <!-- Styles -->
      <link rel="stylesheet" href="style.css">
         </head>
   <body>
            <div class="container">
         <h1 class="title">1: A crash course in C++ and the standard library</h1>
                  <div class="row">
            <div class="col-xl-10"><p><a href="index.html">Back to top</a></p>
<h2 id="the-hello-world-program">The hello world program</h2>
<p>As is tradition in every computer science text, the book starts with a “hello world” program designed to highlight core behaviour of the language. Here’s the source, modified – per my own tradition – to print a slightly modified message:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true"></a><span class="co">// helloworld.cpp</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true"></a><span class="pp">#include </span><span class="im">&lt;iostream&gt;</span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true"></a></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true"></a><span class="dt">int</span> main() {</span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true"></a>    <span class="bu">std::</span>cout &lt;&lt; <span class="st">&quot;Hello cruel world&quot;</span> &lt;&lt; <span class="bu">std::</span>endl;</span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true"></a>    <span class="cf">return</span> <span class="dv">0</span>; </span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true"></a>}</span></code></pre></div>
<h2 id="compiling-helloworld.cpp">Compiling helloworld.cpp</h2>
<p>That’s all well and good, but I can’t do anything useful with this until I compile it, and for that to happen I need a C++ compiler. As it happens I already have g++ on my system, but – for no particular reason – I’ve decided to use clang. Installing clang on ubuntu is pretty straightforward:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode bash"><code class="sourceCode bash"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true"></a><span class="fu">sudo</span> apt install clang</span></code></pre></div>
<p>Now that I have a compiler, I need to actually compile it. Here’s the command:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode bash"><code class="sourceCode bash"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true"></a><span class="fu">clang</span>++ --std=c++20 helloworld.cpp -o helloworld</span></code></pre></div>
<p>The <code>--std=c++20</code> flag tells clang what version of C++ I’m using, and the <code>-o</code> flag is used to specify the output file.</p>
<p>In practice, this isn’t the commmand I actually use. I don’t want my binaries to build into in the same folder as my source code, so I keep all the source code in <code>src</code> and the binaries in <code>bin</code>. Additionally, I’ve done a bit of tinkering and installed clang 15, and I want to use that as my compiler rather than clang 14 (which is what ubuntu ends up installing with the command above). I could tinker with links to set my default clang to version 15, but at some level I think I prefer the command to explicitly specify the compiler version, so my command would actually look like this:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode bash"><code class="sourceCode bash"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true"></a><span class="fu">clang</span>++-15 --std=c++20 ./src/helloworld.cpp -o ./bin/helloworld</span></code></pre></div>
<p>As a side benefit, structuring the project this way makes it much easier to avoid accidentally commiting binary files to the git repository. All I have to do is add the <code>bin</code> folder to my <code>.gitignore</code> file. Fantastic.</p>
<p>That being said, I don’t actually want to type this command for every source file. Instead, because I’m a fundamentally lazy person, I’ve written a <code>Makefile</code> that takes care of that for me, and also renders the markdown files to html. So really the only command I ever use is simply:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode bash"><code class="sourceCode bash"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true"></a><span class="fu">make</span></span></code></pre></div>
<p>Anyway, once the source has been compiled, I can invoke the executable like so:</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode bash"><code class="sourceCode bash"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true"></a><span class="ex">./bin/helloworld</span></span></code></pre></div>
<p>And out pops the message at the terminal:</p>
<pre><code>Hello cruel world</code></pre>
<p>Excellent. The basics are working.</p>
<h2 id="notes-on-helloworld.cpp">Notes on helloworld.cpp</h2>
<p>Thankfully, I’ve written enough C++ code in the past that nothing about this surprises me. A few very basic syntactic notes in case I ever happen to share this with someone else coming from R.</p>
<ul>
<li>Comments in C++ are specified using <code>//</code></li>
<li>Lines must end with the semicolon <code>;</code></li>
<li>The <code>main()</code> function is special: that’s the entry point to your program. This is the function that gets called whenever you invoke the executable at the command line.</li>
<li>Unlike R, C++ is strongly typed, so when you define a function you must specify the output type: so in this case I write <code>int main() { // blah }</code> to specify that the output is an integer</li>
<li>C++ uses namespaces. In R you often see namespaces as package names (e.g., <code>dplyr::filter</code>), and <code>::</code> functions similarly here. When I write <code>std::cout</code>, I’m roughly saying “cout, which lives in the std namespace”.</li>
<li>The <code>#include</code> line is a “preprocessor directive”, used to specify meta-information about the program. In this case, it’s telling the preprocessor to take everything in the <code>&lt;iostream&gt;</code> header file and make it available to the program. Without it, I can’t do any input/output</li>
<li>In theory, since I’m notionally using C++20 in these notes, I could have written <code>import &lt;iostream&gt;;</code> instead of using the <code>#include</code> preprocessor directive. This is because C++20 introduced support for modules. I’m being a bit old-fashioned here, but for a good reason. When I installed clang with the command shown earlier, what I actually got on my system is clang version 14, and the support for modules in clang 14 is limited. I kind of don’t want to get bogged down with those details here, so I’m going to use <code>#include</code> directives instead of trying to get modules working.</li>
</ul>
<p>Going a little deeper:</p>
<ul>
<li><code>std::cout</code> refers to “standard out” (stdout), basically the place where we write output to the console. The metaphor used in the book is to think of it as a “chute” where you toss text.</li>
<li>The <code>&lt;&lt;</code> operator is used to “toss data into the chute”, so <code>std::cout &lt;&lt; "hello"</code> passes the text string <code>"hello"</code> to the standard output. As the helloworld program illustrates, you can concatenate multiple <code>&lt;&lt;</code> operations</li>
<li><code>std::endl</code> represents the end-of-line.</li>
</ul>
<p>If you don’t particularly want to namespace every command, as per <code>std::cout</code>, you can tell the compiler to make the names in a particular namespace available with a <code>using</code> directive (not dissimilar to calling <code>library()</code> in R). So I could have written my helloworld program like this:</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true"></a><span class="co">// helloworld-using.cpp</span></span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true"></a><span class="pp">#include </span><span class="im">&lt;iostream&gt;</span></span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true"></a></span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true"></a><span class="kw">using</span> <span class="kw">namespace</span> std;</span>
<span id="cb8-5"><a href="#cb8-5" aria-hidden="true"></a></span>
<span id="cb8-6"><a href="#cb8-6" aria-hidden="true"></a><span class="dt">int</span> main() {</span>
<span id="cb8-7"><a href="#cb8-7" aria-hidden="true"></a>    cout &lt;&lt; <span class="st">&quot;Hello cruel world&quot;</span> &lt;&lt; endl;</span>
<span id="cb8-8"><a href="#cb8-8" aria-hidden="true"></a>    <span class="cf">return</span> <span class="dv">0</span>; </span>
<span id="cb8-9"><a href="#cb8-9" aria-hidden="true"></a>}</span></code></pre></div>
<p>In general though it’s not a good idea because that leads to namespace conflicts pretty quickly.</p>
<h2 id="variables-types-and-operators">Variables, types, and operators</h2>
<p>The next part of the chapter walks you through variables, operators, types, and so on. Most of this feels very familiar and standard. Yes, C++ is strongly typed and requires variable declaration. This I know. I’ve gotten quite used to writing C++ code like this:</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true"></a><span class="co">// declares variables but does not initalise</span></span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true"></a><span class="dt">int</span> a;</span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true"></a><span class="dt">double</span> b;</span>
<span id="cb9-4"><a href="#cb9-4" aria-hidden="true"></a><span class="dt">bool</span> c;</span>
<span id="cb9-5"><a href="#cb9-5" aria-hidden="true"></a></span>
<span id="cb9-6"><a href="#cb9-6" aria-hidden="true"></a><span class="co">// declares and initialises variables</span></span>
<span id="cb9-7"><a href="#cb9-7" aria-hidden="true"></a><span class="co">// (this uses &quot;uniform initialisation&quot; syntax)</span></span>
<span id="cb9-8"><a href="#cb9-8" aria-hidden="true"></a><span class="dt">int</span> x = <span class="dv">2</span>;</span>
<span id="cb9-9"><a href="#cb9-9" aria-hidden="true"></a><span class="dt">double</span> y = <span class="fl">2.54</span>; </span>
<span id="cb9-10"><a href="#cb9-10" aria-hidden="true"></a><span class="dt">bool</span> z = <span class="kw">true</span>;</span></code></pre></div>
<p>Operators generally feel familiar from other languages. One thing I’ve missed while working in R is the increment and decrement operators, <code>++</code> and <code>--</code>. I have to admit I love these:</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true"></a><span class="co">// increment and decrement with + and -</span></span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true"></a>x = x + <span class="dv">1</span>;</span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true"></a>y = y - <span class="dv">1</span>;</span>
<span id="cb10-4"><a href="#cb10-4" aria-hidden="true"></a></span>
<span id="cb10-5"><a href="#cb10-5" aria-hidden="true"></a><span class="co">// this is the same</span></span>
<span id="cb10-6"><a href="#cb10-6" aria-hidden="true"></a>x++</span>
<span id="cb10-7"><a href="#cb10-7" aria-hidden="true"></a>y--</span></code></pre></div>
<h2 id="casting-and-coercion">Casting and coercion</h2>
<p>The nomenclature used in C++ when talking about changing variable types is a little more precise than it usually is in R. A <strong>cast</strong> is when you explicitly convert from one type to another. In contrast, the term <strong>coercion</strong> is used to describe an implicit cast.</p>
<p>The book gives this as example code. The idea being that you should be able to reason through the steps that the program is following, what cast operations are taking place, and thereby predict what it will print out at the end.</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true"></a><span class="co">// typecasting.cpp</span></span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true"></a><span class="pp">#include </span><span class="im">&lt;iostream&gt;</span></span>
<span id="cb11-3"><a href="#cb11-3" aria-hidden="true"></a></span>
<span id="cb11-4"><a href="#cb11-4" aria-hidden="true"></a><span class="dt">int</span> main() {</span>
<span id="cb11-5"><a href="#cb11-5" aria-hidden="true"></a>    <span class="co">// variable declarations</span></span>
<span id="cb11-6"><a href="#cb11-6" aria-hidden="true"></a>    <span class="dt">int</span> someInteger;</span>
<span id="cb11-7"><a href="#cb11-7" aria-hidden="true"></a>    <span class="dt">short</span> someShort;</span>
<span id="cb11-8"><a href="#cb11-8" aria-hidden="true"></a>    <span class="dt">long</span> someLong;</span>
<span id="cb11-9"><a href="#cb11-9" aria-hidden="true"></a>    <span class="dt">float</span> someFloat;</span>
<span id="cb11-10"><a href="#cb11-10" aria-hidden="true"></a>    <span class="dt">double</span> someDouble;</span>
<span id="cb11-11"><a href="#cb11-11" aria-hidden="true"></a></span>
<span id="cb11-12"><a href="#cb11-12" aria-hidden="true"></a>    <span class="co">// some operations that involve casts</span></span>
<span id="cb11-13"><a href="#cb11-13" aria-hidden="true"></a>    someInteger = <span class="dv">256</span>;</span>
<span id="cb11-14"><a href="#cb11-14" aria-hidden="true"></a>    someInteger++;</span>
<span id="cb11-15"><a href="#cb11-15" aria-hidden="true"></a>    someShort = <span class="kw">static_cast</span>&lt;<span class="dt">short</span>&gt;(someInteger);</span>
<span id="cb11-16"><a href="#cb11-16" aria-hidden="true"></a>    someLong = someShort * <span class="dv">10000</span>;</span>
<span id="cb11-17"><a href="#cb11-17" aria-hidden="true"></a>    someFloat = someLong + <span class="fl">0.785</span><span class="bu">f</span>;</span>
<span id="cb11-18"><a href="#cb11-18" aria-hidden="true"></a>    someDouble = <span class="kw">static_cast</span>&lt;<span class="dt">double</span>&gt;(someFloat) / <span class="dv">100000</span>;</span>
<span id="cb11-19"><a href="#cb11-19" aria-hidden="true"></a></span>
<span id="cb11-20"><a href="#cb11-20" aria-hidden="true"></a>    <span class="co">// print output and return</span></span>
<span id="cb11-21"><a href="#cb11-21" aria-hidden="true"></a>    <span class="bu">std::</span>cout &lt;&lt; someDouble &lt;&lt; <span class="bu">std::</span>endl;</span>
<span id="cb11-22"><a href="#cb11-22" aria-hidden="true"></a>    <span class="cf">return</span> <span class="dv">0</span>;</span>
<span id="cb11-23"><a href="#cb11-23" aria-hidden="true"></a>}</span></code></pre></div>
<p>Okay, I’ll give it a go. Stepping through it line by line…</p>
<ul>
<li>We start out with a signed 32 bit integer <code>someInteger</code> which has value 256.</li>
<li>The <code>++</code> operator increments this to 257.</li>
<li>We then use <code>static_cast()</code> to explicitly cast it to a signed 16 bit integer and store this as <code>someShort</code>.</li>
<li>In the next line we’re multiplying by 10000, which gives us an answer of 2570000. That’s too large a number to store as a 16 bit integer, but because the output variable <code>someLong</code> is typed as a long integer (also 32 bit), coercion takes place. The output is cast implicitly to long there’s an implicit cast happening here (called coercion), and the result is stored as a long integer with value 2570000.</li>
<li>The next line also involves coercion rather than an explicit cast. We’re adding a float (<code>0.785f</code>) to a long integer and storing the result as a float. So the output <code>someFloat</code> has value 2570000.785.</li>
<li>Finally, we explicitly cast <code>someFloat</code> to a double precision floating point number, divide it by 100000, and assign the result to <code>someDouble</code>. That gives us a value of 25.70000785</li>
</ul>
<p>We’ve lost a little precision in the printed output, however, because the program prints 25.7 to stdout.</p>
<h2 id="enumerated-types">Enumerated types</h2>
<p>Next up: “strongly typed enumerated types”. <strong>Enumerated types</strong> are essentially the C++ version of R factors, or Python dictionaries I guess. The key idea is to have a discrete set of labelled values. Internally the objects are encoded as integer values, but those numbers are masked so you can’t do silly things with them. So, for example I could encode gender (somewhat crudely) with an enumerated type as follows:</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true"></a><span class="kw">enum</span> <span class="kw">class</span> Gender { male, female, nonbinary, other, unspecified };</span></code></pre></div>
<p>To declare and initialise some gender variables I would do this:</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true"></a><span class="kw">enum</span> <span class="kw">class</span> Gender { male, female, nonbinary, other, unspecified };</span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true"></a>Gender danielle_gender { Gender::female };</span>
<span id="cb13-3"><a href="#cb13-3" aria-hidden="true"></a>Gender benjamin_gender { Gender::male };</span></code></pre></div>
<p>The internal coding is revealed by this program:</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true"></a><span class="co">// enumerated-types.cpp</span></span>
<span id="cb14-2"><a href="#cb14-2" aria-hidden="true"></a><span class="pp">#include </span><span class="im">&lt;iostream&gt;</span></span>
<span id="cb14-3"><a href="#cb14-3" aria-hidden="true"></a></span>
<span id="cb14-4"><a href="#cb14-4" aria-hidden="true"></a><span class="dt">int</span> main() {</span>
<span id="cb14-5"><a href="#cb14-5" aria-hidden="true"></a>    <span class="kw">enum</span> <span class="kw">class</span> Gender { male, female, nonbinary, other, unspecified };</span>
<span id="cb14-6"><a href="#cb14-6" aria-hidden="true"></a>    Gender danielle_gender { Gender::female };</span>
<span id="cb14-7"><a href="#cb14-7" aria-hidden="true"></a>    Gender benjamin_gender { Gender::male };</span>
<span id="cb14-8"><a href="#cb14-8" aria-hidden="true"></a></span>
<span id="cb14-9"><a href="#cb14-9" aria-hidden="true"></a>    <span class="bu">std::</span>cout &lt;&lt; <span class="st">&quot;Danielle gender: &quot;</span> &lt;&lt; <span class="kw">static_cast</span>&lt;<span class="dt">int</span>&gt;(danielle_gender) &lt;&lt; <span class="bu">std::</span>endl;</span>
<span id="cb14-10"><a href="#cb14-10" aria-hidden="true"></a>    <span class="bu">std::</span>cout &lt;&lt; <span class="st">&quot;Benjamin gender: &quot;</span> &lt;&lt; <span class="kw">static_cast</span>&lt;<span class="dt">int</span>&gt;(benjamin_gender) &lt;&lt; <span class="bu">std::</span>endl;</span>
<span id="cb14-11"><a href="#cb14-11" aria-hidden="true"></a>    <span class="cf">return</span> <span class="dv">0</span>; </span>
<span id="cb14-12"><a href="#cb14-12" aria-hidden="true"></a>}</span></code></pre></div>
<p>When we run this one, the output looks like this:</p>
<pre><code>Danielle gender: 1
Benjamin gender: 0</code></pre>
<h2 id="structs">Structs</h2>
<p>Moving along. The next kind of objects the book considers are <strong>structs</strong>, which allow you to group one or more existing objects (which may themselves be of different types) into a new type. They are, more or less, the C++ analog of lists in R.</p>
<p>It’s not uncommon for C++ code to define a class within a header file which can be made available to the program by an <code>#include</code> directive (or, in C++20, imported as a module). Sticking reasonably closely to what is in the book here, I’ll write a header file that defines an <code>Employee</code> class:</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true"></a><span class="co">// employee.h</span></span>
<span id="cb16-2"><a href="#cb16-2" aria-hidden="true"></a><span class="kw">struct</span> Employee {</span>
<span id="cb16-3"><a href="#cb16-3" aria-hidden="true"></a>    <span class="dt">char</span> firstInitial;</span>
<span id="cb16-4"><a href="#cb16-4" aria-hidden="true"></a>    <span class="dt">char</span> lastInitial;</span>
<span id="cb16-5"><a href="#cb16-5" aria-hidden="true"></a>    <span class="dt">int</span> employeeNumber;</span>
<span id="cb16-6"><a href="#cb16-6" aria-hidden="true"></a>    <span class="dt">int</span> salary;</span>
<span id="cb16-7"><a href="#cb16-7" aria-hidden="true"></a>};</span></code></pre></div>
<p>In the book, the code is a little more elaborate because it explicitly defines a module, but since my compiler has incomplete support for C++20 features, I’m keeping it simple.</p>
<p>A thing to note here is that C++ doesn’t supply a string type out of the box, which is – I would imagine – the reason why this class sidesteps that awkwardness and encodes only the <code>firstInitial</code> and <code>lastInitial</code> as fields in an <code>Employee</code> struct. By doing that we can get away with using a char here. There are of course ways to specify strings, but it’s a bit tangential to the discussion.</p>
<p>Anyway, the key thing is that we access the fields of a struct using <code>.</code> as the code below illustrates:</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true"></a>Employee danielle;</span>
<span id="cb17-2"><a href="#cb17-2" aria-hidden="true"></a>danielle.firstInitial = <span class="ch">&#39;D&#39;</span>;</span>
<span id="cb17-3"><a href="#cb17-3" aria-hidden="true"></a>danielle.lastInitial = <span class="ch">&#39;N&#39;</span>;</span>
<span id="cb17-4"><a href="#cb17-4" aria-hidden="true"></a>danielle.employeeNumber = <span class="dv">69</span>;</span>
<span id="cb17-5"><a href="#cb17-5" aria-hidden="true"></a>danielle.salary = <span class="dv">123456</span>;</span></code></pre></div>
<p>To see it in action we can write a short program. Again we have a bit of an issue because the book uses C++20 features that my compiler doesn’t support. Specifically, it uses the new C++20 <code>&lt;format&gt;</code> module to handle printing, which I don’t have access to. Rather than mess about with compilers to get the new hotness working or introduce an external dependency, I decided to use stringstream objects provided by the <code>&lt;sstream&gt;</code> header file.</p>
<p>So my program looks like this:</p>
<div class="sourceCode" id="cb18"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb18-1"><a href="#cb18-1" aria-hidden="true"></a><span class="co">// employee.cpp</span></span>
<span id="cb18-2"><a href="#cb18-2" aria-hidden="true"></a><span class="pp">#include </span><span class="im">&lt;iostream&gt;</span></span>
<span id="cb18-3"><a href="#cb18-3" aria-hidden="true"></a><span class="pp">#include </span><span class="im">&lt;sstream&gt;</span></span>
<span id="cb18-4"><a href="#cb18-4" aria-hidden="true"></a><span class="pp">#include </span><span class="im">&quot;employee.h&quot;</span></span>
<span id="cb18-5"><a href="#cb18-5" aria-hidden="true"></a></span>
<span id="cb18-6"><a href="#cb18-6" aria-hidden="true"></a><span class="dt">int</span> main() {</span>
<span id="cb18-7"><a href="#cb18-7" aria-hidden="true"></a>    <span class="co">// define the employee record</span></span>
<span id="cb18-8"><a href="#cb18-8" aria-hidden="true"></a>    Employee danielle;</span>
<span id="cb18-9"><a href="#cb18-9" aria-hidden="true"></a>    danielle.firstInitial = <span class="ch">&#39;D&#39;</span>;</span>
<span id="cb18-10"><a href="#cb18-10" aria-hidden="true"></a>    danielle.lastInitial = <span class="ch">&#39;N&#39;</span>;</span>
<span id="cb18-11"><a href="#cb18-11" aria-hidden="true"></a>    danielle.employeeNumber = <span class="dv">69</span>;</span>
<span id="cb18-12"><a href="#cb18-12" aria-hidden="true"></a>    danielle.salary = <span class="dv">123456</span>;</span>
<span id="cb18-13"><a href="#cb18-13" aria-hidden="true"></a></span>
<span id="cb18-14"><a href="#cb18-14" aria-hidden="true"></a>    <span class="co">// write to stdout</span></span>
<span id="cb18-15"><a href="#cb18-15" aria-hidden="true"></a>    <span class="bu">std::</span>stringstream ss;</span>
<span id="cb18-16"><a href="#cb18-16" aria-hidden="true"></a>    ss.str(<span class="st">&quot;&quot;</span>);</span>
<span id="cb18-17"><a href="#cb18-17" aria-hidden="true"></a>    ss &lt;&lt; <span class="st">&quot;Employee: &quot;</span> &lt;&lt; danielle.firstInitial &lt;&lt; danielle.lastInitial;</span>
<span id="cb18-18"><a href="#cb18-18" aria-hidden="true"></a>    <span class="bu">std::</span>cout &lt;&lt; ss.str() &lt;&lt; <span class="bu">std::</span>endl;</span>
<span id="cb18-19"><a href="#cb18-19" aria-hidden="true"></a></span>
<span id="cb18-20"><a href="#cb18-20" aria-hidden="true"></a>    ss.str(<span class="st">&quot;&quot;</span>);</span>
<span id="cb18-21"><a href="#cb18-21" aria-hidden="true"></a>    ss &lt;&lt; <span class="st">&quot;Employee number: #&quot;</span> &lt;&lt; danielle.employeeNumber;</span>
<span id="cb18-22"><a href="#cb18-22" aria-hidden="true"></a>    <span class="bu">std::</span>cout &lt;&lt; ss.str() &lt;&lt; <span class="bu">std::</span>endl;</span>
<span id="cb18-23"><a href="#cb18-23" aria-hidden="true"></a></span>
<span id="cb18-24"><a href="#cb18-24" aria-hidden="true"></a>    ss.str(<span class="st">&quot;&quot;</span>);</span>
<span id="cb18-25"><a href="#cb18-25" aria-hidden="true"></a>    ss &lt;&lt; <span class="st">&quot;Employee salary: $&quot;</span> &lt;&lt; danielle.salary;</span>
<span id="cb18-26"><a href="#cb18-26" aria-hidden="true"></a>    <span class="bu">std::</span>cout &lt;&lt; ss.str() &lt;&lt; <span class="bu">std::</span>endl;</span>
<span id="cb18-27"><a href="#cb18-27" aria-hidden="true"></a></span>
<span id="cb18-28"><a href="#cb18-28" aria-hidden="true"></a>    <span class="cf">return</span> <span class="dv">0</span>;</span>
<span id="cb18-29"><a href="#cb18-29" aria-hidden="true"></a>}</span></code></pre></div>
<p>When I run this program I get this as output:</p>
<pre><code>Employee: DN
Employee number: #69
Employee salary: $123456</code></pre>
<p>That all seems to make sense. What’s next?</p>
<h2 id="digression-poisson-variates">Digression: Poisson variates</h2>
<p>Looking ahead, it seems like the book is about to start discussing conditional branching, functions, loops, and all that good stuff. Fair enough. But conditional branching based on testing some boolean expression is never much fun unless you have a something meaningful to test. Ideally you’d have something where the conditional might evaluate differently. So, since we’re all statisticians here (I mean, it’s just me here and I’m a statistician), this feels like a good moment to divert from the text and write some code that generates Poisson random numbers. To do this I’ll use <code>&lt;random&gt;</code>:</p>
<div class="sourceCode" id="cb20"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb20-1"><a href="#cb20-1" aria-hidden="true"></a><span class="co">// poisson-sample.cpp</span></span>
<span id="cb20-2"><a href="#cb20-2" aria-hidden="true"></a><span class="pp">#include </span><span class="im">&lt;iostream&gt;</span></span>
<span id="cb20-3"><a href="#cb20-3" aria-hidden="true"></a><span class="pp">#include </span><span class="im">&lt;random&gt;</span></span>
<span id="cb20-4"><a href="#cb20-4" aria-hidden="true"></a></span>
<span id="cb20-5"><a href="#cb20-5" aria-hidden="true"></a><span class="dt">int</span> main() {</span>
<span id="cb20-6"><a href="#cb20-6" aria-hidden="true"></a>    <span class="co">// set seed using time, define PRNG with Mersenne Twister</span></span>
<span id="cb20-7"><a href="#cb20-7" aria-hidden="true"></a>    <span class="dt">long</span> <span class="dt">unsigned</span> <span class="dt">int</span> seed = <span class="kw">static_cast</span>&lt;<span class="dt">long</span> <span class="dt">unsigned</span> <span class="dt">int</span>&gt;(time(<span class="dv">0</span>));</span>
<span id="cb20-8"><a href="#cb20-8" aria-hidden="true"></a>    <span class="bu">std::</span>mt19937_64 mersenne {seed};</span>
<span id="cb20-9"><a href="#cb20-9" aria-hidden="true"></a></span>
<span id="cb20-10"><a href="#cb20-10" aria-hidden="true"></a>    <span class="co">// sample_poisson() draws from Poisson(4.1) and returns an integer.</span></span>
<span id="cb20-11"><a href="#cb20-11" aria-hidden="true"></a>    <span class="bu">std::</span>poisson_distribution&lt;<span class="dt">int</span>&gt; sample_poisson(<span class="fl">4.1</span>);</span>
<span id="cb20-12"><a href="#cb20-12" aria-hidden="true"></a></span>
<span id="cb20-13"><a href="#cb20-13" aria-hidden="true"></a>    <span class="co">// draw poisson sample (passing the PRNG as argument) and write to stdout</span></span>
<span id="cb20-14"><a href="#cb20-14" aria-hidden="true"></a>    <span class="bu">std::</span>cout &lt;&lt; <span class="st">&quot;poisson sample: &quot;</span> &lt;&lt; sample_poisson(mersenne) &lt;&lt; <span class="bu">std::</span>endl;</span>
<span id="cb20-15"><a href="#cb20-15" aria-hidden="true"></a>    <span class="cf">return</span> <span class="dv">0</span>;</span>
<span id="cb20-16"><a href="#cb20-16" aria-hidden="true"></a>}</span></code></pre></div>
<p>Here’s what happens when I repeatedly invoke the <code>sample-poisson</code> program at the terminal:</p>
<pre><code>poisson sample: 2
poisson sample: 6
poisson sample: 2
poisson sample: 5
poisson sample: 2
poisson sample: 4
poisson sample: 4</code></pre>
<p>You get the idea.</p>
<h2 id="conditionals">Conditionals</h2>
<p>Okay, back to the development of ideas in the book. Next up is conditional branching, which comes in a few different forms.</p>
<h3 id="ifelse-statements"><code>if/else</code> statements</h3>
<p>the basic syntax is deeply familiar to anyone who has programmed in… pretty much any language I guess. The first example in the book shows a cascading if statement like this:</p>
<div class="sourceCode" id="cb22"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb22-1"><a href="#cb22-1" aria-hidden="true"></a><span class="cf">if</span> (value &gt; <span class="dv">4</span>) {</span>
<span id="cb22-2"><a href="#cb22-2" aria-hidden="true"></a>    <span class="co">// do something</span></span>
<span id="cb22-3"><a href="#cb22-3" aria-hidden="true"></a>} <span class="cf">else</span> <span class="cf">if</span> (value &gt; <span class="dv">2</span>) {</span>
<span id="cb22-4"><a href="#cb22-4" aria-hidden="true"></a>    <span class="co">// do something else</span></span>
<span id="cb22-5"><a href="#cb22-5" aria-hidden="true"></a>} <span class="cf">else</span> {</span>
<span id="cb22-6"><a href="#cb22-6" aria-hidden="true"></a>    <span class="co">// do something else</span></span>
<span id="cb22-7"><a href="#cb22-7" aria-hidden="true"></a>}</span></code></pre></div>
<p>However, the nice thing about having some code to sample random numbers is that I can write something a little less boring here. Here’s a small program that samples a Poisson random variate, and prints a message to the terminal that adds a little comment about where the sample falls relative to the distribution mode:</p>
<div class="sourceCode" id="cb23"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb23-1"><a href="#cb23-1" aria-hidden="true"></a><span class="co">// poisson-conditional.cpp</span></span>
<span id="cb23-2"><a href="#cb23-2" aria-hidden="true"></a><span class="pp">#include </span><span class="im">&lt;iostream&gt;</span></span>
<span id="cb23-3"><a href="#cb23-3" aria-hidden="true"></a><span class="pp">#include </span><span class="im">&lt;random&gt;</span></span>
<span id="cb23-4"><a href="#cb23-4" aria-hidden="true"></a></span>
<span id="cb23-5"><a href="#cb23-5" aria-hidden="true"></a><span class="dt">int</span> main() {</span>
<span id="cb23-6"><a href="#cb23-6" aria-hidden="true"></a>    <span class="co">// define a poisson distribution</span></span>
<span id="cb23-7"><a href="#cb23-7" aria-hidden="true"></a>    <span class="dt">long</span> <span class="dt">unsigned</span> <span class="dt">int</span> seed = <span class="kw">static_cast</span>&lt;<span class="dt">long</span> <span class="dt">unsigned</span> <span class="dt">int</span>&gt;(time(<span class="dv">0</span>));</span>
<span id="cb23-8"><a href="#cb23-8" aria-hidden="true"></a>    <span class="bu">std::</span>mt19937_64 mersenne {seed};</span>
<span id="cb23-9"><a href="#cb23-9" aria-hidden="true"></a>    <span class="bu">std::</span>poisson_distribution&lt;<span class="dt">int</span>&gt; sample_poisson(<span class="fl">4.1</span>);</span>
<span id="cb23-10"><a href="#cb23-10" aria-hidden="true"></a></span>
<span id="cb23-11"><a href="#cb23-11" aria-hidden="true"></a>    <span class="co">// sample a value and write first part of message</span></span>
<span id="cb23-12"><a href="#cb23-12" aria-hidden="true"></a>    <span class="dt">int</span> value = sample_poisson(mersenne);</span>
<span id="cb23-13"><a href="#cb23-13" aria-hidden="true"></a>    <span class="bu">std::</span>cout &lt;&lt; <span class="st">&quot;The sampled value of &quot;</span> &lt;&lt; value;</span>
<span id="cb23-14"><a href="#cb23-14" aria-hidden="true"></a></span>
<span id="cb23-15"><a href="#cb23-15" aria-hidden="true"></a>    <span class="co">// remainder of message depends on the value</span></span>
<span id="cb23-16"><a href="#cb23-16" aria-hidden="true"></a>    <span class="cf">if</span> (value == <span class="dv">4</span>) {</span>
<span id="cb23-17"><a href="#cb23-17" aria-hidden="true"></a>        <span class="bu">std::</span>cout &lt;&lt; <span class="st">&quot; is the modal value.&quot;</span> &lt;&lt; <span class="bu">std::</span>endl;</span>
<span id="cb23-18"><a href="#cb23-18" aria-hidden="true"></a>    } <span class="cf">else</span> <span class="cf">if</span> (value &lt; <span class="dv">4</span>) {</span>
<span id="cb23-19"><a href="#cb23-19" aria-hidden="true"></a>        <span class="bu">std::</span>cout &lt;&lt; <span class="st">&quot; is below the mode.&quot;</span> &lt;&lt; <span class="bu">std::</span>endl;</span>
<span id="cb23-20"><a href="#cb23-20" aria-hidden="true"></a>    } <span class="cf">else</span> {</span>
<span id="cb23-21"><a href="#cb23-21" aria-hidden="true"></a>        <span class="bu">std::</span>cout &lt;&lt; <span class="st">&quot; is above the mode.&quot;</span> &lt;&lt; <span class="bu">std::</span>endl;</span>
<span id="cb23-22"><a href="#cb23-22" aria-hidden="true"></a>    }</span>
<span id="cb23-23"><a href="#cb23-23" aria-hidden="true"></a>    <span class="cf">return</span> <span class="dv">0</span>;</span>
<span id="cb23-24"><a href="#cb23-24" aria-hidden="true"></a>}</span></code></pre></div>
<p>Again, here’s some output I get when I repeatedly invoke the <code>poisson-conditional</code> function:</p>
<pre><code>The sampled value of 11 is above the mode.
The sampled value of 4 is the modal value.
The sampled value of 6 is above the mode.
The sampled value of 5 is above the mode.
The sampled value of 4 is the modal value.
The sampled value of 3 is below the mode.</code></pre>
<p>Exciting times in the life of Danielle.</p>
<h3 id="if-else-statements-with-initialisers"><code>if-else</code> statements with initialisers</h3>
<p>At this point the book introduces a concept I wasn’t familiar with. You can include an initialiser within an if/else block, where you can define variables that exist only within the scope of that block. The basic syntax looks like this:</p>
<div class="sourceCode" id="cb25"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb25-1"><a href="#cb25-1" aria-hidden="true"></a><span class="cf">if</span> (&lt;initialiser&gt;; &lt;conditional_expression&gt;) {</span>
<span id="cb25-2"><a href="#cb25-2" aria-hidden="true"></a>    &lt;if_body&gt;</span>
<span id="cb25-3"><a href="#cb25-3" aria-hidden="true"></a>} <span class="cf">else</span> <span class="cf">if</span> (&lt;else_if_expression&gt;) {</span>
<span id="cb25-4"><a href="#cb25-4" aria-hidden="true"></a>    &lt;else_if_body&gt;</span>
<span id="cb25-5"><a href="#cb25-5" aria-hidden="true"></a>} <span class="cf">else</span> {</span>
<span id="cb25-6"><a href="#cb25-6" aria-hidden="true"></a>    &lt;else_body&gt;</span>
<span id="cb25-7"><a href="#cb25-7" aria-hidden="true"></a>}</span></code></pre></div>
<p>The book doesn’t give an example of this at this early stage because, rather sensibly, the author hasn’t gone down the weird little digression into Poisson variates that I did. But, having done so, it’s easy to write a variant of the previous program that creates the random value within the initialiser:</p>
<div class="sourceCode" id="cb26"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb26-1"><a href="#cb26-1" aria-hidden="true"></a><span class="co">// poisson-initialised-conditional.cpp</span></span>
<span id="cb26-2"><a href="#cb26-2" aria-hidden="true"></a><span class="pp">#include </span><span class="im">&lt;iostream&gt;</span></span>
<span id="cb26-3"><a href="#cb26-3" aria-hidden="true"></a><span class="pp">#include </span><span class="im">&lt;random&gt;</span></span>
<span id="cb26-4"><a href="#cb26-4" aria-hidden="true"></a></span>
<span id="cb26-5"><a href="#cb26-5" aria-hidden="true"></a><span class="dt">int</span> main() {</span>
<span id="cb26-6"><a href="#cb26-6" aria-hidden="true"></a>    <span class="co">// define a poisson distribution</span></span>
<span id="cb26-7"><a href="#cb26-7" aria-hidden="true"></a>    <span class="dt">long</span> <span class="dt">unsigned</span> <span class="dt">int</span> seed = <span class="kw">static_cast</span>&lt;<span class="dt">long</span> <span class="dt">unsigned</span> <span class="dt">int</span>&gt;(time(<span class="dv">0</span>));</span>
<span id="cb26-8"><a href="#cb26-8" aria-hidden="true"></a>    <span class="bu">std::</span>mt19937_64 mersenne {seed};</span>
<span id="cb26-9"><a href="#cb26-9" aria-hidden="true"></a>    <span class="bu">std::</span>poisson_distribution&lt;<span class="dt">int</span>&gt; sample_poisson(<span class="fl">4.1</span>);</span>
<span id="cb26-10"><a href="#cb26-10" aria-hidden="true"></a></span>
<span id="cb26-11"><a href="#cb26-11" aria-hidden="true"></a>    <span class="co">// conditional statement with an initialiser</span></span>
<span id="cb26-12"><a href="#cb26-12" aria-hidden="true"></a>    <span class="cf">if</span> (<span class="dt">int</span> x = sample_poisson(mersenne); x == <span class="dv">4</span>) {</span>
<span id="cb26-13"><a href="#cb26-13" aria-hidden="true"></a>        <span class="bu">std::</span>cout &lt;&lt; x &lt;&lt; <span class="st">&quot; is the modal value.&quot;</span> &lt;&lt; <span class="bu">std::</span>endl;</span>
<span id="cb26-14"><a href="#cb26-14" aria-hidden="true"></a>    } <span class="cf">else</span> <span class="cf">if</span> (x &lt; <span class="dv">4</span>) {</span>
<span id="cb26-15"><a href="#cb26-15" aria-hidden="true"></a>        <span class="bu">std::</span>cout &lt;&lt; x &lt;&lt; <span class="st">&quot; is below the mode.&quot;</span> &lt;&lt; <span class="bu">std::</span>endl;</span>
<span id="cb26-16"><a href="#cb26-16" aria-hidden="true"></a>    } <span class="cf">else</span> {</span>
<span id="cb26-17"><a href="#cb26-17" aria-hidden="true"></a>        <span class="bu">std::</span>cout &lt;&lt; x &lt;&lt; <span class="st">&quot; is above the mode.&quot;</span> &lt;&lt; <span class="bu">std::</span>endl;</span>
<span id="cb26-18"><a href="#cb26-18" aria-hidden="true"></a>    }</span>
<span id="cb26-19"><a href="#cb26-19" aria-hidden="true"></a>    <span class="cf">return</span> <span class="dv">0</span>;</span>
<span id="cb26-20"><a href="#cb26-20" aria-hidden="true"></a>}</span></code></pre></div>
<p>In this code, the variable <code>x</code> exists only within the scope of the if/else statement. Here’s a few results from running this program several times:</p>
<pre><code>7 is above the mode.
4 is the modal value.
3 is below the mode.
8 is above the mode.</code></pre>
<h3 id="switchcase-statements"><code>switch/case</code> statements</h3>
<div class="sourceCode" id="cb28"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb28-1"><a href="#cb28-1" aria-hidden="true"></a><span class="co">// gender-switch.cpp</span></span>
<span id="cb28-2"><a href="#cb28-2" aria-hidden="true"></a><span class="pp">#include </span><span class="im">&lt;iostream&gt;</span></span>
<span id="cb28-3"><a href="#cb28-3" aria-hidden="true"></a></span>
<span id="cb28-4"><a href="#cb28-4" aria-hidden="true"></a><span class="dt">int</span> main() {</span>
<span id="cb28-5"><a href="#cb28-5" aria-hidden="true"></a>    <span class="kw">enum</span> <span class="kw">class</span> Gender { male, female, nonbinary, other, unspecified };</span>
<span id="cb28-6"><a href="#cb28-6" aria-hidden="true"></a>    Gender danielle_gender { Gender::female };</span>
<span id="cb28-7"><a href="#cb28-7" aria-hidden="true"></a></span>
<span id="cb28-8"><a href="#cb28-8" aria-hidden="true"></a>    <span class="bu">std::</span>cout &lt;&lt; <span class="st">&quot;Danielle&#39;s gender is &quot;</span>;</span>
<span id="cb28-9"><a href="#cb28-9" aria-hidden="true"></a>    <span class="cf">switch</span> (danielle_gender) {</span>
<span id="cb28-10"><a href="#cb28-10" aria-hidden="true"></a>        <span class="cf">case</span> Gender::female:</span>
<span id="cb28-11"><a href="#cb28-11" aria-hidden="true"></a>        <span class="cf">case</span> Gender::male:</span>
<span id="cb28-12"><a href="#cb28-12" aria-hidden="true"></a>            <span class="bu">std::</span>cout &lt;&lt; <span class="st">&quot;within the gender binary&quot;</span> &lt;&lt; <span class="bu">std::</span>endl;</span>
<span id="cb28-13"><a href="#cb28-13" aria-hidden="true"></a>            <span class="cf">break</span>;</span>
<span id="cb28-14"><a href="#cb28-14" aria-hidden="true"></a>        <span class="cf">case</span> Gender::nonbinary:</span>
<span id="cb28-15"><a href="#cb28-15" aria-hidden="true"></a>        <span class="cf">case</span> Gender::other:</span>
<span id="cb28-16"><a href="#cb28-16" aria-hidden="true"></a>            <span class="bu">std::</span>cout &lt;&lt; <span class="st">&quot;outside the gender binary&quot;</span> &lt;&lt; <span class="bu">std::</span>endl;</span>
<span id="cb28-17"><a href="#cb28-17" aria-hidden="true"></a>            <span class="cf">break</span>;</span>
<span id="cb28-18"><a href="#cb28-18" aria-hidden="true"></a>        <span class="cf">default</span>:</span>
<span id="cb28-19"><a href="#cb28-19" aria-hidden="true"></a>            <span class="bu">std::</span>cout &lt;&lt; <span class="st">&quot;unspecified&quot;</span> &lt;&lt; <span class="bu">std::</span>endl;</span>
<span id="cb28-20"><a href="#cb28-20" aria-hidden="true"></a>    }</span>
<span id="cb28-21"><a href="#cb28-21" aria-hidden="true"></a>}</span></code></pre></div>
<p>When this code is executed, we get this:</p>
<pre><code>Danielle&#39;s gender is within the gender binary</code></pre>
<p>The reason this happens is due to <strong>fallthrough</strong> behaviour. When a <code>case</code> expression that matches the <code>switch</code> expression is reached, all subsequent statements are executed until a <code>break</code> statement is reached. So even though there’s nothing to execute immediately following the <code>Gender::female</code> case expression, there’s no <code>break</code> there either, so the flow “falls through” to the next case. In other words, inthis code male and female genders will both produce “within the gender binary” as the printed message, whereas nonbinary and other genders will produce “outside the gender binary” as the message. If the gender is unspecified, none of the case expressions will match against the switch expression, so the default message at the end is printed.</p>
<p>Just like with <code>if/else</code> blocks, <code>switch</code> blocks can use initialisers:</p>
<div class="sourceCode" id="cb30"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb30-1"><a href="#cb30-1" aria-hidden="true"></a><span class="co">// gender-switch-2.cpp</span></span>
<span id="cb30-2"><a href="#cb30-2" aria-hidden="true"></a><span class="pp">#include </span><span class="im">&lt;iostream&gt;</span></span>
<span id="cb30-3"><a href="#cb30-3" aria-hidden="true"></a></span>
<span id="cb30-4"><a href="#cb30-4" aria-hidden="true"></a><span class="dt">int</span> main() {</span>
<span id="cb30-5"><a href="#cb30-5" aria-hidden="true"></a>    <span class="kw">enum</span> <span class="kw">class</span> Gender { male, female, nonbinary, other, unspecified };</span>
<span id="cb30-6"><a href="#cb30-6" aria-hidden="true"></a></span>
<span id="cb30-7"><a href="#cb30-7" aria-hidden="true"></a>    <span class="cf">switch</span> (Gender x { Gender::unspecified }; x) {</span>
<span id="cb30-8"><a href="#cb30-8" aria-hidden="true"></a>        <span class="cf">case</span> Gender::female:</span>
<span id="cb30-9"><a href="#cb30-9" aria-hidden="true"></a>        <span class="cf">case</span> Gender::male:</span>
<span id="cb30-10"><a href="#cb30-10" aria-hidden="true"></a>            <span class="bu">std::</span>cout &lt;&lt; <span class="st">&quot;Within the gender binary&quot;</span> &lt;&lt; <span class="bu">std::</span>endl;</span>
<span id="cb30-11"><a href="#cb30-11" aria-hidden="true"></a>            <span class="cf">break</span>;</span>
<span id="cb30-12"><a href="#cb30-12" aria-hidden="true"></a>        <span class="cf">case</span> Gender::nonbinary:</span>
<span id="cb30-13"><a href="#cb30-13" aria-hidden="true"></a>        <span class="cf">case</span> Gender::other:</span>
<span id="cb30-14"><a href="#cb30-14" aria-hidden="true"></a>            <span class="bu">std::</span>cout &lt;&lt; <span class="st">&quot;Outside the gender binary&quot;</span> &lt;&lt; <span class="bu">std::</span>endl;</span>
<span id="cb30-15"><a href="#cb30-15" aria-hidden="true"></a>            <span class="cf">break</span>;</span>
<span id="cb30-16"><a href="#cb30-16" aria-hidden="true"></a>        <span class="cf">case</span> Gender::unspecified:</span>
<span id="cb30-17"><a href="#cb30-17" aria-hidden="true"></a>            <span class="bu">std::</span>cout &lt;&lt; <span class="st">&quot;Gender unspecified&quot;</span> &lt;&lt; <span class="bu">std::</span>endl;</span>
<span id="cb30-18"><a href="#cb30-18" aria-hidden="true"></a>    }</span>
<span id="cb30-19"><a href="#cb30-19" aria-hidden="true"></a>}</span></code></pre></div>
<p>The output here is:</p>
<pre><code>Gender unspecified</code></pre>
<h3 id="conditional-operator">Conditional operator</h3>
<p>You can also use <code>?</code> and <code>:</code> to create a conditional expression. The general syntax is</p>
<div class="sourceCode" id="cb32"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb32-1"><a href="#cb32-1" aria-hidden="true"></a>&lt;condition&gt; ? &lt;value_if_condition_true&gt; : &lt;value_if_condition_false&gt;;</span></code></pre></div>
<p>Here’s a simple example:</p>
<div class="sourceCode" id="cb33"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb33-1"><a href="#cb33-1" aria-hidden="true"></a><span class="bu">std::</span>cout &lt;&lt; ((p_value &lt; <span class="fl">.05</span>) ? <span class="st">&quot;reject null&quot;</span> : <span class="st">&quot;retain null&quot;</span>);</span></code></pre></div>
<p>Cool Continuing on.</p>
<h2 id="logical-expressions">Logical expressions</h2>
<p>There’s not much to say here. C++ operators are mostly the same as anywhere else:</p>
<ul>
<li>Inequality operators: <code>&gt;</code>, <code>&gt;=</code>, <code>&lt;</code>, <code>&lt;=</code></li>
<li>Equality operator: <code>==</code></li>
<li>Not-equal operator: <code>!=</code></li>
<li>Not operator: <code>!</code></li>
<li>And operator: <code>&amp;&amp;</code></li>
<li>Or operator: <code>||</code></li>
</ul>
<p>Absolutely riveting content, honestly. I’m on the edge of my seat. About the only thing worth mentioning is that C++ uses <strong>short circuit</strong> rules to evaluate logical expressions. A logical expression is evaluated only until the result is guaranteed. Later steps are not evaluated. For instance:</p>
<div class="sourceCode" id="cb34"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb34-1"><a href="#cb34-1" aria-hidden="true"></a><span class="dt">bool</span> result { boolean_eval_to_false || <span class="kw">true</span> || boolean_is_irrelevant }</span></code></pre></div>
<p>In this case <code>boolean_eval_to_false</code> is evaluated (returning <code>false</code>). That doesn’t guarantee the final result though, because the expressions are joined by <code>||</code>. However, the next expression is <code>true</code>, which means that <code>result</code> must equal <code>true</code>. Consequently the expression as a whole short-circuits, and <code>boolean_is_irrelevant</code> is never evaluated. This trick is used a lot for efficiency: if you put the computationally cheap tests first and the computationally expensive tests last, you may be able to avoid ever having to perform the expensive tests.</p>
<h2 id="functions">Functions</h2>
<p>So far all the programs I’ve looked at have included a <code>main()</code> function and nothing else. Every time I’ve declared my <code>main()</code> function the code has looked like this:</p>
<div class="sourceCode" id="cb35"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb35-1"><a href="#cb35-1" aria-hidden="true"></a><span class="dt">int</span> main() {</span>
<span id="cb35-2"><a href="#cb35-2" aria-hidden="true"></a>    <span class="co">// meaningful content here</span></span>
<span id="cb35-3"><a href="#cb35-3" aria-hidden="true"></a>    <span class="co">// return to user</span></span>
<span id="cb35-4"><a href="#cb35-4" aria-hidden="true"></a>    <span class="cf">return</span> <span class="dv">0</span>;</span>
<span id="cb35-5"><a href="#cb35-5" aria-hidden="true"></a>}</span></code></pre></div>
<p>By writing the declaration in this way we are asserting the <code>main()</code> function always returns an <code>int</code> value, and indeed when we look at the <code>return</code> statement at the end, it always does. Admittedly, I’ve never used this return value for anything, but it’s a requirement in C++ that the <code>main()</code> function return an integer.</p>
<p>Other functions aren’t constrained in the same way, and in fact C++ functions don’t have to return anything if the only reason to call the function is for its side effects. To do that we set the output type to <code>void</code>. Here’s an example:</p>
<div class="sourceCode" id="cb36"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb36-1"><a href="#cb36-1" aria-hidden="true"></a><span class="co">// char-code.cpp</span></span>
<span id="cb36-2"><a href="#cb36-2" aria-hidden="true"></a><span class="pp">#include </span><span class="im">&lt;iostream&gt;</span></span>
<span id="cb36-3"><a href="#cb36-3" aria-hidden="true"></a></span>
<span id="cb36-4"><a href="#cb36-4" aria-hidden="true"></a><span class="dt">void</span> print_ascii_code(<span class="dt">char</span> c) {</span>
<span id="cb36-5"><a href="#cb36-5" aria-hidden="true"></a>    <span class="bu">std::</span>cout &lt;&lt; c &lt;&lt; <span class="st">&quot; has integer code &quot;</span> &lt;&lt; <span class="kw">static_cast</span>&lt;<span class="dt">int</span>&gt;(c) &lt;&lt; <span class="bu">std::</span>endl;</span>
<span id="cb36-6"><a href="#cb36-6" aria-hidden="true"></a>}</span>
<span id="cb36-7"><a href="#cb36-7" aria-hidden="true"></a></span>
<span id="cb36-8"><a href="#cb36-8" aria-hidden="true"></a><span class="dt">int</span> main() {</span>
<span id="cb36-9"><a href="#cb36-9" aria-hidden="true"></a>    print_ascii_code(<span class="ch">&#39;d&#39;</span>);</span>
<span id="cb36-10"><a href="#cb36-10" aria-hidden="true"></a>    print_ascii_code(<span class="ch">&#39;a&#39;</span>);</span>
<span id="cb36-11"><a href="#cb36-11" aria-hidden="true"></a>    print_ascii_code(<span class="ch">&#39;n&#39;</span>);</span>
<span id="cb36-12"><a href="#cb36-12" aria-hidden="true"></a>    print_ascii_code(<span class="ch">&#39;i&#39;</span>);</span>
<span id="cb36-13"><a href="#cb36-13" aria-hidden="true"></a>}</span></code></pre></div>
<p>When I run this program I get this:</p>
<pre><code>d has integer code 100
a has integer code 97
n has integer code 110
i has integer code 105</code></pre>
<p>(The integers correspond to the ASCII codes for each character).</p>
<h3 id="useful-tidbits-about-functions">Useful tidbits about functions</h3>
<ol type="1">
<li>It’s possible to use the <code>auto</code> keyword to ask the compiler to figure out the output type for you. So, for instance, this works and returns an integer:</li>
</ol>
<div class="sourceCode" id="cb38"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb38-1"><a href="#cb38-1" aria-hidden="true"></a><span class="kw">auto</span> add_numbers(<span class="dt">int</span> x, <span class="dt">int</span> y) {</span>
<span id="cb38-2"><a href="#cb38-2" aria-hidden="true"></a>    <span class="cf">return</span> x + y;</span>
<span id="cb38-3"><a href="#cb38-3" aria-hidden="true"></a>}</span></code></pre></div>
<ol start="2" type="1">
<li>Every function has a local variable <code>__func__</code> that contains the function name. As noted in the book, this can be helpful for logging purposes. Here’s a slightly expanded version of the example used in the book:</li>
</ol>
<div class="sourceCode" id="cb39"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb39-1"><a href="#cb39-1" aria-hidden="true"></a><span class="co">// add-with-logging.cpp</span></span>
<span id="cb39-2"><a href="#cb39-2" aria-hidden="true"></a><span class="pp">#include </span><span class="im">&lt;iostream&gt;</span></span>
<span id="cb39-3"><a href="#cb39-3" aria-hidden="true"></a></span>
<span id="cb39-4"><a href="#cb39-4" aria-hidden="true"></a><span class="dt">int</span> add_numbers(<span class="dt">int</span> x, <span class="dt">int</span> y) {</span>
<span id="cb39-5"><a href="#cb39-5" aria-hidden="true"></a>    <span class="bu">std::</span>cout &lt;&lt; <span class="ot">__func__</span> &lt;&lt; <span class="st">&quot;(&quot;</span> &lt;&lt; x &lt;&lt; <span class="st">&quot;, &quot;</span> &lt;&lt; y &lt;&lt; <span class="st">&quot;)&quot;</span> &lt;&lt; <span class="bu">std::</span>endl;</span>
<span id="cb39-6"><a href="#cb39-6" aria-hidden="true"></a>    <span class="cf">return</span> x + y;</span>
<span id="cb39-7"><a href="#cb39-7" aria-hidden="true"></a>}</span>
<span id="cb39-8"><a href="#cb39-8" aria-hidden="true"></a></span>
<span id="cb39-9"><a href="#cb39-9" aria-hidden="true"></a><span class="dt">int</span> main() {</span>
<span id="cb39-10"><a href="#cb39-10" aria-hidden="true"></a>    <span class="dt">int</span> a = <span class="dv">1</span>;</span>
<span id="cb39-11"><a href="#cb39-11" aria-hidden="true"></a>    <span class="dt">int</span> b = <span class="dv">2</span>;</span>
<span id="cb39-12"><a href="#cb39-12" aria-hidden="true"></a>    <span class="dt">int</span> c = <span class="dv">3</span>;</span>
<span id="cb39-13"><a href="#cb39-13" aria-hidden="true"></a>    <span class="dt">int</span> sum1 = add_numbers(a, b);</span>
<span id="cb39-14"><a href="#cb39-14" aria-hidden="true"></a>    <span class="dt">int</span> sum2 = add_numbers(sum1, c);</span>
<span id="cb39-15"><a href="#cb39-15" aria-hidden="true"></a>    <span class="bu">std::</span>cout &lt;&lt; <span class="st">&quot;result: &quot;</span> &lt;&lt; sum2 &lt;&lt; <span class="bu">std::</span>endl;</span>
<span id="cb39-16"><a href="#cb39-16" aria-hidden="true"></a>    <span class="cf">return</span> <span class="dv">0</span>;</span>
<span id="cb39-17"><a href="#cb39-17" aria-hidden="true"></a>}</span></code></pre></div>
<p>When this executes, we see the following written to stdout:</p>
<pre><code>add_numbers(1, 2)
add_numbers(3, 3)
result: 6</code></pre>
<ol start="3" type="1">
<li>Function overloading is permitted: you can write multiple functions that have the same name but have different signatures. Note that in this case that means the function arguments must be different. It’s not sufficient merely to declare a different output type. As an example, we could use this to define addition functions that accept both integers and doubles, returning integers only if both arguments are integers:</li>
</ol>
<div class="sourceCode" id="cb41"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb41-1"><a href="#cb41-1" aria-hidden="true"></a><span class="co">// add-with-overloading.cpp</span></span>
<span id="cb41-2"><a href="#cb41-2" aria-hidden="true"></a><span class="pp">#include </span><span class="im">&lt;iostream&gt;</span></span>
<span id="cb41-3"><a href="#cb41-3" aria-hidden="true"></a></span>
<span id="cb41-4"><a href="#cb41-4" aria-hidden="true"></a><span class="dt">int</span> add_numbers(<span class="dt">int</span> x, <span class="dt">int</span> y) {</span>
<span id="cb41-5"><a href="#cb41-5" aria-hidden="true"></a>    <span class="bu">std::</span>cout &lt;&lt; <span class="ot">__func__</span> &lt;&lt; <span class="st">&quot;(&quot;</span> &lt;&lt; x &lt;&lt; <span class="st">&quot;, &quot;</span> &lt;&lt; y &lt;&lt; <span class="st">&quot;)&quot;</span> &lt;&lt; <span class="bu">std::</span>endl;</span>
<span id="cb41-6"><a href="#cb41-6" aria-hidden="true"></a>    <span class="cf">return</span> x + y;</span>
<span id="cb41-7"><a href="#cb41-7" aria-hidden="true"></a>}</span>
<span id="cb41-8"><a href="#cb41-8" aria-hidden="true"></a></span>
<span id="cb41-9"><a href="#cb41-9" aria-hidden="true"></a><span class="dt">double</span> add_numbers(<span class="dt">double</span> x, <span class="dt">double</span> y) {</span>
<span id="cb41-10"><a href="#cb41-10" aria-hidden="true"></a>    <span class="bu">std::</span>cout &lt;&lt; <span class="ot">__func__</span> &lt;&lt; <span class="st">&quot;(&quot;</span> &lt;&lt; x &lt;&lt; <span class="st">&quot;, &quot;</span> &lt;&lt; y &lt;&lt; <span class="st">&quot;)&quot;</span> &lt;&lt; <span class="bu">std::</span>endl;</span>
<span id="cb41-11"><a href="#cb41-11" aria-hidden="true"></a>    <span class="cf">return</span> x + y;</span>
<span id="cb41-12"><a href="#cb41-12" aria-hidden="true"></a>}</span>
<span id="cb41-13"><a href="#cb41-13" aria-hidden="true"></a></span>
<span id="cb41-14"><a href="#cb41-14" aria-hidden="true"></a><span class="dt">double</span> add_numbers(<span class="dt">int</span> x, <span class="dt">double</span> y) {</span>
<span id="cb41-15"><a href="#cb41-15" aria-hidden="true"></a>    <span class="bu">std::</span>cout &lt;&lt; <span class="ot">__func__</span> &lt;&lt; <span class="st">&quot;(&quot;</span> &lt;&lt; x &lt;&lt; <span class="st">&quot;, &quot;</span> &lt;&lt; y &lt;&lt; <span class="st">&quot;)&quot;</span> &lt;&lt; <span class="bu">std::</span>endl;</span>
<span id="cb41-16"><a href="#cb41-16" aria-hidden="true"></a>    <span class="cf">return</span> <span class="kw">static_cast</span>&lt;<span class="dt">double</span>&gt;(x) + y;</span>
<span id="cb41-17"><a href="#cb41-17" aria-hidden="true"></a>}</span>
<span id="cb41-18"><a href="#cb41-18" aria-hidden="true"></a></span>
<span id="cb41-19"><a href="#cb41-19" aria-hidden="true"></a><span class="dt">double</span> add_numbers(<span class="dt">double</span> x, <span class="dt">int</span> y) {</span>
<span id="cb41-20"><a href="#cb41-20" aria-hidden="true"></a>    <span class="bu">std::</span>cout &lt;&lt; <span class="ot">__func__</span> &lt;&lt; <span class="st">&quot;(&quot;</span> &lt;&lt; x &lt;&lt; <span class="st">&quot;, &quot;</span> &lt;&lt; y &lt;&lt; <span class="st">&quot;)&quot;</span> &lt;&lt; <span class="bu">std::</span>endl;</span>
<span id="cb41-21"><a href="#cb41-21" aria-hidden="true"></a>    <span class="cf">return</span> x + <span class="kw">static_cast</span>&lt;<span class="dt">double</span>&gt;(y);</span>
<span id="cb41-22"><a href="#cb41-22" aria-hidden="true"></a>}</span>
<span id="cb41-23"><a href="#cb41-23" aria-hidden="true"></a></span>
<span id="cb41-24"><a href="#cb41-24" aria-hidden="true"></a></span>
<span id="cb41-25"><a href="#cb41-25" aria-hidden="true"></a><span class="dt">int</span> main() {</span>
<span id="cb41-26"><a href="#cb41-26" aria-hidden="true"></a>    <span class="dt">int</span> int_a = <span class="dv">1</span>;</span>
<span id="cb41-27"><a href="#cb41-27" aria-hidden="true"></a>    <span class="dt">int</span> int_b = <span class="dv">2</span>;</span>
<span id="cb41-28"><a href="#cb41-28" aria-hidden="true"></a>    <span class="dt">double</span> dbl_c = <span class="fl">3.45</span>;</span>
<span id="cb41-29"><a href="#cb41-29" aria-hidden="true"></a>    <span class="dt">double</span> dbl_d = <span class="fl">6.78</span>;</span>
<span id="cb41-30"><a href="#cb41-30" aria-hidden="true"></a></span>
<span id="cb41-31"><a href="#cb41-31" aria-hidden="true"></a>    <span class="dt">int</span> int_ab = add_numbers(int_a, int_b);</span>
<span id="cb41-32"><a href="#cb41-32" aria-hidden="true"></a>    <span class="dt">double</span> dbl_cd = add_numbers(dbl_c, dbl_d);</span>
<span id="cb41-33"><a href="#cb41-33" aria-hidden="true"></a>    <span class="dt">double</span> dbl_abcd = add_numbers(int_ab, dbl_cd);</span>
<span id="cb41-34"><a href="#cb41-34" aria-hidden="true"></a>    <span class="bu">std::</span>cout &lt;&lt; <span class="st">&quot;result: &quot;</span> &lt;&lt; dbl_abcd &lt;&lt; <span class="bu">std::</span>endl;</span>
<span id="cb41-35"><a href="#cb41-35" aria-hidden="true"></a>    <span class="cf">return</span> <span class="dv">0</span>;</span>
<span id="cb41-36"><a href="#cb41-36" aria-hidden="true"></a>}</span></code></pre></div>
<p>Running this code produces the following output:</p>
<pre><code>add_numbers(1, 2)
add_numbers(3.45, 6.78)
add_numbers(3, 10.23)
result: 13.23</code></pre>
<p>It works, but it can be a bit risky to abandon type stability. In this case it’s quite easy to reason about the output type of a call to <code>add_numbers()</code> simply by inspecting the input types, but in my experience things go bad quite quickly when you don’t take type stability seriously.</p>
<ol start="4" type="1">
<li>You can specify attributes like <code>[[maybe_unused]]</code> to indicate that, for instance, a function argument might not be used. There are other attributes like <code>[[deprecated]]</code> for functions, and – though I skipped that bit earlier, attributes like <code>[[fallthrough]]</code> for switch statements. To be honest, at this point I’m only lightly reading the sections on attributes.</li>
</ol>
<h2 id="arrays">Arrays</h2>
<p>At this point, the book moves to a discussion of arrays. Specifically, it first talks about old-school C-style arrays before moving onto the C++ <code>std::array</code> type. Given that I try my very best never to use C-style arrays in my C++ code, I think I’ll skip straight to <code>std::array</code> in these notes. C++ style array objects are provided by the <code>&lt;array&gt;</code> library. The size of the array must be specified in advance, and all elements of the array must have the same type. Indexing starts at 0.</p>
<p>Here’s a simple example:</p>
<div class="sourceCode" id="cb43"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb43-1"><a href="#cb43-1" aria-hidden="true"></a><span class="co">// array-danielle.cpp</span></span>
<span id="cb43-2"><a href="#cb43-2" aria-hidden="true"></a><span class="pp">#include </span><span class="im">&lt;iostream&gt;</span></span>
<span id="cb43-3"><a href="#cb43-3" aria-hidden="true"></a><span class="pp">#include </span><span class="im">&lt;array&gt;</span></span>
<span id="cb43-4"><a href="#cb43-4" aria-hidden="true"></a></span>
<span id="cb43-5"><a href="#cb43-5" aria-hidden="true"></a><span class="dt">int</span> main() {</span>
<span id="cb43-6"><a href="#cb43-6" aria-hidden="true"></a>    <span class="bu">std::</span>array&lt;<span class="dt">char</span>, <span class="dv">8</span>&gt; danielle = { <span class="ch">&#39;D&#39;</span>, <span class="ch">&#39;a&#39;</span>, <span class="ch">&#39;n&#39;</span>, <span class="ch">&#39;i&#39;</span>, <span class="ch">&#39;e&#39;</span>, <span class="ch">&#39;l&#39;</span>, <span class="ch">&#39;l&#39;</span>, <span class="ch">&#39;e&#39;</span> };</span>
<span id="cb43-7"><a href="#cb43-7" aria-hidden="true"></a>    <span class="bu">std::</span>cout &lt;&lt; <span class="st">&quot;Danielle has &quot;</span> &lt;&lt; danielle.size() &lt;&lt; <span class="st">&quot; letters.&quot;</span> &lt;&lt; <span class="bu">std::</span>endl;</span>
<span id="cb43-8"><a href="#cb43-8" aria-hidden="true"></a>}</span></code></pre></div>
<p>The nice thing here is that C++ arrays have a <code>.size()</code> method which makes it easy to do all sort of operations with them. The current example is a bit minimal: I’m just using it to count the letters in my name. Speaking of which, here’s the output:</p>
<pre><code>Danielle has 8 letters.</code></pre>
<h2 id="vectors">Vectors</h2>
<p>In many situations you don’t know in advance how many elements you need to store. To help with that, C++ provides the <code>std::vector</code> type via the <code>&lt;vector&gt;</code> library. Vectors are flexible containers that can grow and shrink at run time, so you don’t need to specify how long they will be and you don’t have to faff about with memory managemtn. Because vectors are more useful than arrays (in my experience) I’ll give an example that roughly mirrors a situation I’ve had to deal with in real life: when you’re collecting observations and you don’t know in advance how many observations might arise. In real applications the source of this variation usually comes from the outside source, but for this example I’ll rely on my new best friend, the <a href="https://cplusplus.com/reference/random/"><code>&lt;random&gt;</code></a> library.</p>
<p>I’ll switch to statistical notation here. In the code below I assume the number of observations <span class="math inline">\(n\)</span> follows a Poisson distribution with rate parameter <span class="math inline">\(\lambda\)</span>:</p>
<p><span class="math display">\[
n \sim \mbox{Poisson}(\lambda)
\]</span></p>
<p>and I’ll assume each value <span class="math inline">\(v\)</span> is a Beta variate between 0 and 1:</p>
<p><span class="math display">\[ 
v \sim \mbox{Beta}(a, b)
\]</span></p>
<p>Annoyingly, the <code>&lt;random&gt;</code> library does not supply functions for beta distributions out of the box but happily I have not forgotten my basic variate relations. To sample <span class="math inline">\(v\)</span> from a Beta distribution I can draw two Gamma variates <span class="math inline">\(x\)</span> and <span class="math inline">\(y\)</span> as follows:</p>
<p><span class="math display">\[
\begin{array}{rcl}
x &amp; \sim &amp; \mbox{Gamma}(a, 1) \\
y &amp; \sim &amp; \mbox{Gamma}(b, 1)
\end{array}
\]</span></p>
<p>and set <span class="math inline">\(v = x/(x + y)\)</span>. Problem solved.</p>
<p>Anyway, here’s the code:</p>
<div class="sourceCode" id="cb45"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb45-1"><a href="#cb45-1" aria-hidden="true"></a><span class="co">// beta-sample.cpp</span></span>
<span id="cb45-2"><a href="#cb45-2" aria-hidden="true"></a><span class="pp">#include </span><span class="im">&lt;iostream&gt;</span></span>
<span id="cb45-3"><a href="#cb45-3" aria-hidden="true"></a><span class="pp">#include </span><span class="im">&lt;vector&gt;</span></span>
<span id="cb45-4"><a href="#cb45-4" aria-hidden="true"></a><span class="pp">#include </span><span class="im">&lt;random&gt;</span></span>
<span id="cb45-5"><a href="#cb45-5" aria-hidden="true"></a></span>
<span id="cb45-6"><a href="#cb45-6" aria-hidden="true"></a><span class="dt">void</span> print_message(<span class="dt">double</span> value, <span class="dt">double</span> a, <span class="dt">double</span> b) {</span>
<span id="cb45-7"><a href="#cb45-7" aria-hidden="true"></a>    <span class="bu">std::</span>cout &lt;&lt; <span class="st">&quot;beta(&quot;</span> &lt;&lt; a &lt;&lt; <span class="st">&quot;,&quot;</span> &lt;&lt; b &lt;&lt; <span class="st">&quot;) sample: &quot;</span> &lt;&lt; value &lt;&lt; <span class="bu">std::</span>endl;</span>
<span id="cb45-8"><a href="#cb45-8" aria-hidden="true"></a>}</span>
<span id="cb45-9"><a href="#cb45-9" aria-hidden="true"></a></span>
<span id="cb45-10"><a href="#cb45-10" aria-hidden="true"></a><span class="bu">std::</span>vector&lt;<span class="dt">double</span>&gt; draw_betas(<span class="dt">double</span> rate, <span class="dt">double</span> a, <span class="dt">double</span> b) {</span>
<span id="cb45-11"><a href="#cb45-11" aria-hidden="true"></a>    <span class="co">// distributions</span></span>
<span id="cb45-12"><a href="#cb45-12" aria-hidden="true"></a>    <span class="bu">std::</span>gamma_distribution&lt;<span class="dt">double</span>&gt; gamma_a(a, <span class="fl">1.0</span>);</span>
<span id="cb45-13"><a href="#cb45-13" aria-hidden="true"></a>    <span class="bu">std::</span>gamma_distribution&lt;<span class="dt">double</span>&gt; gamma_b(b, <span class="fl">1.0</span>);</span>
<span id="cb45-14"><a href="#cb45-14" aria-hidden="true"></a>    <span class="bu">std::</span>poisson_distribution&lt;<span class="dt">int</span>&gt; poisson(rate);</span>
<span id="cb45-15"><a href="#cb45-15" aria-hidden="true"></a></span>
<span id="cb45-16"><a href="#cb45-16" aria-hidden="true"></a>    <span class="co">// mersenne twister numbers</span></span>
<span id="cb45-17"><a href="#cb45-17" aria-hidden="true"></a>    <span class="bu">std::</span>random_device rd;</span>
<span id="cb45-18"><a href="#cb45-18" aria-hidden="true"></a>    <span class="bu">std::</span>mt19937 mt(rd());</span>
<span id="cb45-19"><a href="#cb45-19" aria-hidden="true"></a></span>
<span id="cb45-20"><a href="#cb45-20" aria-hidden="true"></a>    <span class="co">// draw poisson sample to determine number of betas</span></span>
<span id="cb45-21"><a href="#cb45-21" aria-hidden="true"></a>    <span class="dt">int</span> n = poisson(mt);</span>
<span id="cb45-22"><a href="#cb45-22" aria-hidden="true"></a></span>
<span id="cb45-23"><a href="#cb45-23" aria-hidden="true"></a>    <span class="co">// draw beta samples and return</span></span>
<span id="cb45-24"><a href="#cb45-24" aria-hidden="true"></a>    <span class="bu">std::</span>vector&lt;<span class="dt">double</span>&gt; beta_variates {};</span>
<span id="cb45-25"><a href="#cb45-25" aria-hidden="true"></a>    <span class="dt">double</span> x, y;</span>
<span id="cb45-26"><a href="#cb45-26" aria-hidden="true"></a>    <span class="cf">for</span> (<span class="dt">int</span> i = <span class="dv">0</span>; i &lt; n; i++) {</span>
<span id="cb45-27"><a href="#cb45-27" aria-hidden="true"></a>        x = gamma_a(mt);</span>
<span id="cb45-28"><a href="#cb45-28" aria-hidden="true"></a>        y = gamma_b(mt);</span>
<span id="cb45-29"><a href="#cb45-29" aria-hidden="true"></a>        beta_variates.push_back(x / (x + y));</span>
<span id="cb45-30"><a href="#cb45-30" aria-hidden="true"></a>    }</span>
<span id="cb45-31"><a href="#cb45-31" aria-hidden="true"></a>    <span class="cf">return</span> beta_variates;</span>
<span id="cb45-32"><a href="#cb45-32" aria-hidden="true"></a>}</span>
<span id="cb45-33"><a href="#cb45-33" aria-hidden="true"></a></span>
<span id="cb45-34"><a href="#cb45-34" aria-hidden="true"></a><span class="dt">int</span> main() {</span>
<span id="cb45-35"><a href="#cb45-35" aria-hidden="true"></a>    <span class="at">const</span> <span class="dt">double</span> a = <span class="fl">2.0</span>; <span class="co">// shape parameter 1</span></span>
<span id="cb45-36"><a href="#cb45-36" aria-hidden="true"></a>    <span class="at">const</span> <span class="dt">double</span> b = <span class="fl">1.0</span>; <span class="co">// shape parameter 2</span></span>
<span id="cb45-37"><a href="#cb45-37" aria-hidden="true"></a>    <span class="at">const</span> <span class="dt">double</span> rate = <span class="fl">2.4</span>; <span class="co">// rate for poisson dist</span></span>
<span id="cb45-38"><a href="#cb45-38" aria-hidden="true"></a></span>
<span id="cb45-39"><a href="#cb45-39" aria-hidden="true"></a>    <span class="co">// draw samples</span></span>
<span id="cb45-40"><a href="#cb45-40" aria-hidden="true"></a>    <span class="bu">std::</span>vector&lt;<span class="dt">double</span>&gt; betas = draw_betas(rate, a, b);</span>
<span id="cb45-41"><a href="#cb45-41" aria-hidden="true"></a></span>
<span id="cb45-42"><a href="#cb45-42" aria-hidden="true"></a>    <span class="co">// print messages and return</span></span>
<span id="cb45-43"><a href="#cb45-43" aria-hidden="true"></a>    <span class="bu">std::</span>cout &lt;&lt; <span class="st">&quot;collected &quot;</span> &lt;&lt; betas.size() &lt;&lt; <span class="st">&quot; samples&quot;</span> &lt;&lt; <span class="bu">std::</span>endl;</span>
<span id="cb45-44"><a href="#cb45-44" aria-hidden="true"></a>    <span class="cf">for</span> (<span class="dt">int</span> i = <span class="dv">0</span>; i &lt; betas.size(); i++) {</span>
<span id="cb45-45"><a href="#cb45-45" aria-hidden="true"></a>        print_message(betas[i], a, b);</span>
<span id="cb45-46"><a href="#cb45-46" aria-hidden="true"></a>    }</span>
<span id="cb45-47"><a href="#cb45-47" aria-hidden="true"></a>    <span class="cf">return</span> <span class="dv">0</span>;</span>
<span id="cb45-48"><a href="#cb45-48" aria-hidden="true"></a>}</span></code></pre></div>
<p>Technically I’m getting slightly ahead of the book here because it hasn’t talked about loops yet, but whatever. A <code>for</code> loop is more or less the same thing everywhere.</p>
<p>Anyway, let’s take a quick look at some output. Sometimes this code creates a <code>betas</code> vector containing four values:</p>
<pre><code>collected 4 samples
beta(2,1) sample: 0.293596
beta(2,1) sample: 0.920161
beta(2,1) sample: 0.971502
beta(2,1) sample: 0.502786</code></pre>
<p>Sometimes the <code>betas</code> vector has no values:</p>
<pre><code>collected 4 samples</code></pre>
<p>Sometimes we sample two values, so the output looks like this:</p>
<pre><code>collected 2 samples
beta(2,1) sample: 0.729145
beta(2,1) sample: 0.414129</code></pre>
<p>And so on.</p>
<h2 id="pairs-and-optionals">Pairs and optionals</h2>
<p>At this point the book discusses a couple of topics that I’m not going to bother writing my own code for:</p>
<ul>
<li><p>C++ provides a <code>std::pair</code> class via the <code>&lt;utility&gt;</code> library. It’s used to group two values that can be of different types. It has methods <code>.first()</code> and <code>.second()</code> to extract individual elements. I can imagine this is useful as a tool for representing name-value pairs, for instance.</p></li>
<li><p>There is an <code>std::optional</code> class provided by <code>&lt;optional&gt;</code> and can either hold a value of a specific type, or nothing. There’s a method <code>.has_value()</code> that returns a boolean specifying whether a value has een stored, and a <code>.value()</code> method that returns the stored value. Apparently you can also use the dereferencing operator to do the same thing, so if we have an optional object called <code>maybe</code> then <code>maybe.value()</code> and <code>*maybe</code> do the same thing. There’s also a <code>.value_or()</code> method that returns the stored value if one exists, or else returns whatever is passed to <code>.value_or()</code>. The obvious application that comes to mind for me is that optional objects could be used to handle missing values in statistical contexts.</p></li>
</ul>
<h2 id="structured-bindings">Structured bindings</h2>
<p>Structured bindings were introduced in C++17 and allow you to declare and assign multiple variables at once, using values taken from an appropriate object: arrays, structs, pairs, and tuples all work for this. The main use case I can see for this that it provides a clean way to allow function to return multiple values. On the function side, you wrap the outputs into an appropriate structure (the example below uses a tuple). Then when the function is called elsewhere, use the structured bindings syntax to assign the elements of the wrapping structure (e.g., the tuple) directly into their own variables. for example, let’s suppose I’ve written <code>some_function()</code> that returns a 3-tuple. I can assign the elements of that tuple to variables <code>x</code>, <code>y</code> and <code>z</code> like so:</p>
<div class="sourceCode" id="cb49"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb49-1"><a href="#cb49-1" aria-hidden="true"></a><span class="kw">auto</span> [x, y, z] = some_function();</span></code></pre></div>
<p>Back in my MATLAB days I used to do this all the time. In R it’s slightly trickier to do that unless you’re using specialised packages that provide multiple assignment functionality. Anyway, here’s a contrived example:</p>
<div class="sourceCode" id="cb50"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb50-1"><a href="#cb50-1" aria-hidden="true"></a><span class="co">// structured-binding-asl.cpp</span></span>
<span id="cb50-2"><a href="#cb50-2" aria-hidden="true"></a><span class="pp">#include </span><span class="im">&lt;iostream&gt;</span></span>
<span id="cb50-3"><a href="#cb50-3" aria-hidden="true"></a><span class="pp">#include </span><span class="im">&lt;tuple&gt;</span></span>
<span id="cb50-4"><a href="#cb50-4" aria-hidden="true"></a><span class="pp">#include </span><span class="im">&lt;string&gt;</span></span>
<span id="cb50-5"><a href="#cb50-5" aria-hidden="true"></a></span>
<span id="cb50-6"><a href="#cb50-6" aria-hidden="true"></a><span class="co">// somewhat absurd function used to illustrate the point</span></span>
<span id="cb50-7"><a href="#cb50-7" aria-hidden="true"></a><span class="bu">std::</span>tuple&lt;<span class="dt">int</span>, <span class="dt">char</span>, <span class="bu">std::</span>string&gt; asl() {</span>
<span id="cb50-8"><a href="#cb50-8" aria-hidden="true"></a>    <span class="cf">return</span> {<span class="dv">45</span>, <span class="ch">&#39;F&#39;</span>, <span class="st">&quot;Sydney&quot;</span>};</span>
<span id="cb50-9"><a href="#cb50-9" aria-hidden="true"></a>}</span>
<span id="cb50-10"><a href="#cb50-10" aria-hidden="true"></a></span>
<span id="cb50-11"><a href="#cb50-11" aria-hidden="true"></a><span class="dt">int</span> main() {</span>
<span id="cb50-12"><a href="#cb50-12" aria-hidden="true"></a>    <span class="co">// use structured bindings to declare and assign multiple </span></span>
<span id="cb50-13"><a href="#cb50-13" aria-hidden="true"></a>    <span class="co">// variables from the output returned by the function call</span></span>
<span id="cb50-14"><a href="#cb50-14" aria-hidden="true"></a>    <span class="kw">auto</span> [age, sex, location] = asl();</span>
<span id="cb50-15"><a href="#cb50-15" aria-hidden="true"></a></span>
<span id="cb50-16"><a href="#cb50-16" aria-hidden="true"></a>    <span class="co">// messages</span></span>
<span id="cb50-17"><a href="#cb50-17" aria-hidden="true"></a>    <span class="bu">std::</span>cout &lt;&lt; <span class="st">&quot;age: &quot;</span> &lt;&lt; age &lt;&lt; <span class="bu">std::</span>endl;</span>
<span id="cb50-18"><a href="#cb50-18" aria-hidden="true"></a>    <span class="bu">std::</span>cout &lt;&lt; <span class="st">&quot;sex: &quot;</span> &lt;&lt; sex &lt;&lt; <span class="bu">std::</span>endl;</span>
<span id="cb50-19"><a href="#cb50-19" aria-hidden="true"></a>    <span class="bu">std::</span>cout &lt;&lt; <span class="st">&quot;location: &quot;</span> &lt;&lt; location &lt;&lt; <span class="bu">std::</span>endl;</span>
<span id="cb50-20"><a href="#cb50-20" aria-hidden="true"></a>    <span class="cf">return</span> <span class="dv">0</span>;</span>
<span id="cb50-21"><a href="#cb50-21" aria-hidden="true"></a>}</span></code></pre></div>
<p>For the sake of keeping these notes family-friendly I have restricted myself to “a/s/l”, even though the term “structured bindings” itself suggests the possibility of a rather more… expansive… query that might be adopted here.</p>
<p>Aaaaaaanyway… the results:</p>
<pre><code>age: 45
sex: F
location: Sydney</code></pre>
<h2 id="loops">Loops</h2>
<p>The book now turns to loops. I’m trying very hard not to start skimming in case there’s something secific to C++ that I need to know, but honestly this all feels very, very familiar. To keep my boredom to a minimum I’ll try to find examples that I find entertaining.</p>
<h3 id="the-while-loop">The <code>while</code> loop</h3>
<p>First up, a <strong>while</strong> loop calculating the sequence of integers <span class="math inline">\(x_1, x_2, \ldots\)</span></p>
<p><span class="math display">\[
x_{n+1} = \left\{ 
\begin{array}{rl} 
x_n/2 &amp; \mbox{if $x_n$ is even} \\    
3x_n +1 &amp; \mbox{if $x_n$ is odd} \\  
\end{array}  
\right.
\]</span></p>
<p>terminating at the first <span class="math inline">\(n\)</span> such that <span class="math inline">\(x_n = 1\)</span>. This is of course an implementation of the <a href="https://en.wikipedia.org/wiki/Collatz_conjecture">collatz conjecture</a> which proposes that this collatz sequence, for every integer-valued choice of initial value <span class="math inline">\(x_0\)</span>, eventually terminates in 1. Code:</p>
<div class="sourceCode" id="cb52"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb52-1"><a href="#cb52-1" aria-hidden="true"></a><span class="co">// collatz.cpp</span></span>
<span id="cb52-2"><a href="#cb52-2" aria-hidden="true"></a><span class="pp">#include </span><span class="im">&lt;iostream&gt;</span></span>
<span id="cb52-3"><a href="#cb52-3" aria-hidden="true"></a></span>
<span id="cb52-4"><a href="#cb52-4" aria-hidden="true"></a><span class="dt">int</span> main() {</span>
<span id="cb52-5"><a href="#cb52-5" aria-hidden="true"></a>    <span class="dt">int</span> value = <span class="dv">39</span>;</span>
<span id="cb52-6"><a href="#cb52-6" aria-hidden="true"></a>    <span class="bu">std::</span>cout &lt;&lt; value;</span>
<span id="cb52-7"><a href="#cb52-7" aria-hidden="true"></a>    <span class="cf">while</span> (value != <span class="dv">1</span>) {</span>
<span id="cb52-8"><a href="#cb52-8" aria-hidden="true"></a>        value = (value % <span class="dv">2</span> == <span class="dv">0</span>) ? (value / <span class="dv">2</span>) : (<span class="dv">3</span> * value + <span class="dv">1</span>);</span>
<span id="cb52-9"><a href="#cb52-9" aria-hidden="true"></a>        <span class="bu">std::</span>cout &lt;&lt; <span class="st">&quot; -&gt; &quot;</span> &lt;&lt; value;</span>
<span id="cb52-10"><a href="#cb52-10" aria-hidden="true"></a>    }</span>
<span id="cb52-11"><a href="#cb52-11" aria-hidden="true"></a>    <span class="bu">std::</span>cout &lt;&lt; <span class="bu">std::</span>endl;</span>
<span id="cb52-12"><a href="#cb52-12" aria-hidden="true"></a>    <span class="cf">return</span> <span class="dv">0</span>;</span>
<span id="cb52-13"><a href="#cb52-13" aria-hidden="true"></a>}</span></code></pre></div>
<p>The results for <span class="math inline">\(x_0 = 39\)</span>, where I’ve manually added linebreaks:</p>
<pre><code>39 -&gt; 118 -&gt; 59 -&gt; 178 -&gt; 89 -&gt; 268 -&gt; 134 -&gt; 67 -&gt; 
202 -&gt; 101 -&gt; 304 -&gt; 152 -&gt; 76 -&gt; 38 -&gt; 19 -&gt; 58 -&gt; 
29 -&gt; 88 -&gt; 44 -&gt; 22 -&gt; 11 -&gt; 34 -&gt; 17 -&gt; 52 -&gt; 26 -&gt; 
13 -&gt; 40 -&gt; 20 -&gt; 10 -&gt; 5 -&gt; 16 -&gt; 8 -&gt; 4 -&gt; 2 -&gt; 1</code></pre>
<h3 id="the-dowhile-loop">The <code>do/while</code> loop</h3>
<p>The <code>do/while</code> loop is inherently boring, but is very occasionally handy if it is important to ensure that the code block is executed at least once. This pattern makes sense when, for example, you might need to repeatedly check something until it produces valid output. In that situation a while loop does make sense, but you really have to run <em>at least</em> once test in order to validate… whatever it is you’re trying to validate.</p>
<p>As a truly absurd example:</p>
<div class="sourceCode" id="cb54"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb54-1"><a href="#cb54-1" aria-hidden="true"></a><span class="co">// validation-check.cpp</span></span>
<span id="cb54-2"><a href="#cb54-2" aria-hidden="true"></a><span class="pp">#include </span><span class="im">&lt;iostream&gt;</span></span>
<span id="cb54-3"><a href="#cb54-3" aria-hidden="true"></a><span class="pp">#include </span><span class="im">&lt;ctime&gt;</span></span>
<span id="cb54-4"><a href="#cb54-4" aria-hidden="true"></a></span>
<span id="cb54-5"><a href="#cb54-5" aria-hidden="true"></a><span class="dt">bool</span> valid_time() {</span>
<span id="cb54-6"><a href="#cb54-6" aria-hidden="true"></a>    <span class="bu">std::</span>time_t elapsed = <span class="bu">std::</span>time(<span class="kw">nullptr</span>);</span>
<span id="cb54-7"><a href="#cb54-7" aria-hidden="true"></a>    <span class="dt">bool</span> is_valid = elapsed % <span class="dv">2</span> == <span class="dv">0</span>;</span>
<span id="cb54-8"><a href="#cb54-8" aria-hidden="true"></a>    <span class="cf">if</span> (is_valid) {</span>
<span id="cb54-9"><a href="#cb54-9" aria-hidden="true"></a>        <span class="bu">std::</span>cout &lt;&lt; elapsed &lt;&lt; <span class="st">&quot; seconds since the epoch&quot;</span> &lt;&lt; <span class="bu">std::</span>endl;</span>
<span id="cb54-10"><a href="#cb54-10" aria-hidden="true"></a>    }</span>
<span id="cb54-11"><a href="#cb54-11" aria-hidden="true"></a>    <span class="cf">return</span> is_valid;</span>
<span id="cb54-12"><a href="#cb54-12" aria-hidden="true"></a>}</span>
<span id="cb54-13"><a href="#cb54-13" aria-hidden="true"></a></span>
<span id="cb54-14"><a href="#cb54-14" aria-hidden="true"></a><span class="dt">int</span> main() {</span>
<span id="cb54-15"><a href="#cb54-15" aria-hidden="true"></a>    <span class="dt">bool</span> valid;</span>
<span id="cb54-16"><a href="#cb54-16" aria-hidden="true"></a>    <span class="dt">int</span> i = <span class="dv">0</span>;</span>
<span id="cb54-17"><a href="#cb54-17" aria-hidden="true"></a>    <span class="cf">do</span> {</span>
<span id="cb54-18"><a href="#cb54-18" aria-hidden="true"></a>        i++;</span>
<span id="cb54-19"><a href="#cb54-19" aria-hidden="true"></a>    } <span class="cf">while</span> (!valid_time());</span>
<span id="cb54-20"><a href="#cb54-20" aria-hidden="true"></a>    <span class="bu">std::</span>cout &lt;&lt; <span class="st">&quot;attempts = &quot;</span> &lt;&lt; i &lt;&lt; <span class="bu">std::</span>endl;</span>
<span id="cb54-21"><a href="#cb54-21" aria-hidden="true"></a>    <span class="cf">return</span> <span class="dv">0</span>;</span>
<span id="cb54-22"><a href="#cb54-22" aria-hidden="true"></a>}</span></code></pre></div>
<p>This code checks the current time, measured in number of seconds since the unix epoch. If that number is even, it deems the time to be “valid” and prints the elapsed seconds to stdout. If that number is odd, it deems the time to be “invalid” and refuses to terminate the <code>do/while</code> loop. That leads to some entertaining behaviour. About half the time you’ll get output like this where it succeeds the first time:</p>
<pre><code>1687250594 seconds since the epoch
attempts = 1</code></pre>
<p>But the other half of time the program fails about 200 million times before finally succeeding:</p>
<pre><code>1687250596 seconds since the epoch
attempts = 200744719</code></pre>
<p>Suffice it to say, although the idea of using <code>do/while</code> loops to implement validation checks makes sense, this is… um… an unhinged example. But I found it funny so I ran with it.</p>
<h3 id="the-for-loop">The <code>for</code> loop</h3>
<p>One of the earlier examples gave an example of a <code>for</code> loop that was semi-serious, so I feel justified in being absurd again:</p>
<div class="sourceCode" id="cb57"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb57-1"><a href="#cb57-1" aria-hidden="true"></a><span class="co">// na-na-hey-hey.cpp</span></span>
<span id="cb57-2"><a href="#cb57-2" aria-hidden="true"></a><span class="pp">#include </span><span class="im">&lt;iostream&gt;</span></span>
<span id="cb57-3"><a href="#cb57-3" aria-hidden="true"></a></span>
<span id="cb57-4"><a href="#cb57-4" aria-hidden="true"></a><span class="dt">int</span> main() {</span>
<span id="cb57-5"><a href="#cb57-5" aria-hidden="true"></a>    <span class="cf">for</span>(<span class="dt">int</span> i = <span class="dv">0</span>; i &lt; <span class="dv">8</span>; i++) { <span class="bu">std::</span>cout &lt;&lt; <span class="st">&quot;na &quot;</span>; }</span>
<span id="cb57-6"><a href="#cb57-6" aria-hidden="true"></a>    <span class="cf">for</span>(<span class="dt">int</span> i = <span class="dv">0</span>; i &lt; <span class="dv">3</span>; i++) { <span class="bu">std::</span>cout &lt;&lt; <span class="st">&quot;hey &quot;</span>; }</span>
<span id="cb57-7"><a href="#cb57-7" aria-hidden="true"></a>    <span class="bu">std::</span>cout &lt;&lt; <span class="st">&quot;goodbye&quot;</span> &lt;&lt; <span class="bu">std::</span>endl;</span>
<span id="cb57-8"><a href="#cb57-8" aria-hidden="true"></a>    <span class="cf">return</span> <span class="dv">0</span>;</span>
<span id="cb57-9"><a href="#cb57-9" aria-hidden="true"></a>}</span></code></pre></div>
<div class="sourceCode" id="cb58" data-startFrom="1"><pre class="sourceCode numberSource bash numberLines"><code class="sourceCode bash"><span id="cb58-1"><a href="#cb58-1"></a><span class="ex">./bin/01/na-na-hey-hey</span></span></code></pre></div>
<pre class="stdout"><code>na na na na na na na na hey hey hey goodbye</code></pre>
<h3 id="the-range-based-for-loop">The range-based <code>for</code> loop</h3>
<p>The range-based <code>for</code> loop iterates directly over the elements of a container. It works for a fairly wide range of possible containers: anything that has <code>.begin()</code> and <code>.end()</code> methods that return iterators will work. Example:</p>
<div class="sourceCode" id="cb60"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb60-1"><a href="#cb60-1" aria-hidden="true"></a><span class="co">// array-iterator.cpp</span></span>
<span id="cb60-2"><a href="#cb60-2" aria-hidden="true"></a><span class="pp">#include </span><span class="im">&lt;iostream&gt;</span></span>
<span id="cb60-3"><a href="#cb60-3" aria-hidden="true"></a><span class="pp">#include </span><span class="im">&lt;array&gt;</span></span>
<span id="cb60-4"><a href="#cb60-4" aria-hidden="true"></a></span>
<span id="cb60-5"><a href="#cb60-5" aria-hidden="true"></a><span class="dt">int</span> main() {</span>
<span id="cb60-6"><a href="#cb60-6" aria-hidden="true"></a>    <span class="bu">std::</span>array&lt;<span class="dt">int</span>, <span class="dv">6</span>&gt; fib = { <span class="dv">1</span>, <span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>, <span class="dv">5</span>, <span class="dv">8</span> };</span>
<span id="cb60-7"><a href="#cb60-7" aria-hidden="true"></a>    <span class="cf">for</span>(<span class="dt">int</span> f : fib) { <span class="bu">std::</span>cout &lt;&lt; f &lt;&lt; <span class="bu">std::</span>endl; }</span>
<span id="cb60-8"><a href="#cb60-8" aria-hidden="true"></a>    <span class="cf">return</span> <span class="dv">0</span>;</span>
<span id="cb60-9"><a href="#cb60-9" aria-hidden="true"></a>}</span></code></pre></div>
<div class="sourceCode" id="cb61" data-startFrom="2"><pre class="sourceCode numberSource bash numberLines"><code class="sourceCode bash" style="counter-reset: source-line 1;"><span id="cb61-2"><a href="#cb61-2"></a><span class="ex">./bin/01/array-iterator</span></span></code></pre></div>
<pre class="stdout"><code>1
1
2
3
5
8</code></pre>
<p>Note that in this code, at each step of the iteration the variable <code>f</code> stores a copy of the relevant element of <code>fib</code>. However, it’s possible to do range-based <code>for</code> loops without making copies by using a reference variable. The book promises to discuss this later in the chapter.</p>
<h2 id="initialiser-lists">Initialiser lists</h2>
<p>Initialiser lists are designed to make it easy to write functions that accept a variable number of arguments, and are provided by the <code>&lt;initializer_list&gt;</code> library. All values in an initialiser list must be the same type. Here’s an example that computes the mean of an arbitrary number of double values:</p>
<div class="sourceCode" id="cb63"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb63-1"><a href="#cb63-1" aria-hidden="true"></a><span class="co">// mean-value.cpp</span></span>
<span id="cb63-2"><a href="#cb63-2" aria-hidden="true"></a><span class="pp">#include </span><span class="im">&lt;iostream&gt;</span></span>
<span id="cb63-3"><a href="#cb63-3" aria-hidden="true"></a><span class="pp">#include </span><span class="im">&lt;initializer_list&gt;</span></span>
<span id="cb63-4"><a href="#cb63-4" aria-hidden="true"></a></span>
<span id="cb63-5"><a href="#cb63-5" aria-hidden="true"></a><span class="dt">double</span> mean(<span class="bu">std::</span>initializer_list&lt;<span class="dt">double</span>&gt; values) {</span>
<span id="cb63-6"><a href="#cb63-6" aria-hidden="true"></a>    <span class="dt">double</span> tot = <span class="dv">0</span>;</span>
<span id="cb63-7"><a href="#cb63-7" aria-hidden="true"></a>    <span class="cf">for</span> (<span class="dt">double</span> v : values) {</span>
<span id="cb63-8"><a href="#cb63-8" aria-hidden="true"></a>        tot += v;</span>
<span id="cb63-9"><a href="#cb63-9" aria-hidden="true"></a>    }</span>
<span id="cb63-10"><a href="#cb63-10" aria-hidden="true"></a>    <span class="cf">return</span> tot / values.size();</span>
<span id="cb63-11"><a href="#cb63-11" aria-hidden="true"></a>} </span>
<span id="cb63-12"><a href="#cb63-12" aria-hidden="true"></a></span>
<span id="cb63-13"><a href="#cb63-13" aria-hidden="true"></a><span class="dt">int</span> main() {</span>
<span id="cb63-14"><a href="#cb63-14" aria-hidden="true"></a>    <span class="dt">double</span> x_bar = mean({ <span class="fl">2.3</span>, <span class="fl">1.5</span>, <span class="fl">7.8</span>, <span class="fl">11.0</span> });</span>
<span id="cb63-15"><a href="#cb63-15" aria-hidden="true"></a>    <span class="dt">double</span> y_bar = mean({ <span class="fl">102.5</span>, <span class="fl">59.1</span>, <span class="fl">98.2</span> });</span>
<span id="cb63-16"><a href="#cb63-16" aria-hidden="true"></a>    <span class="bu">std::</span>cout &lt;&lt; <span class="st">&quot;mean x: &quot;</span> &lt;&lt; x_bar &lt;&lt; <span class="bu">std::</span>endl;</span>
<span id="cb63-17"><a href="#cb63-17" aria-hidden="true"></a>    <span class="bu">std::</span>cout &lt;&lt; <span class="st">&quot;mean y: &quot;</span> &lt;&lt; y_bar &lt;&lt; <span class="bu">std::</span>endl;</span>
<span id="cb63-18"><a href="#cb63-18" aria-hidden="true"></a>    <span class="cf">return</span> <span class="dv">0</span>;</span>
<span id="cb63-19"><a href="#cb63-19" aria-hidden="true"></a>}</span></code></pre></div>
<div class="sourceCode" id="cb64" data-startFrom="6"><pre class="sourceCode numberSource bash numberLines"><code class="sourceCode bash" style="counter-reset: source-line 5;"><span id="cb64-6"><a href="#cb64-6"></a><span class="ex">./bin/01/mean-value</span></span></code></pre></div>
<pre class="stdout"><code>mean x: 5.65
mean y: 86.6</code></pre>
<h2 id="strings">Strings</h2>
<p>The book talks about strings next, but it’s mostly a promissory note here. It mentions that the <code>std::string</code> type from <code>&lt;string&gt;</code> works more or less the way you’d expect for a string type. Here’s a quick example:</p>
<div class="sourceCode" id="cb66"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb66-1"><a href="#cb66-1" aria-hidden="true"></a><span class="co">// simple-string.cpp</span></span>
<span id="cb66-2"><a href="#cb66-2" aria-hidden="true"></a><span class="pp">#include </span><span class="im">&lt;iostream&gt;</span></span>
<span id="cb66-3"><a href="#cb66-3" aria-hidden="true"></a><span class="pp">#include </span><span class="im">&lt;vector&gt;</span></span>
<span id="cb66-4"><a href="#cb66-4" aria-hidden="true"></a><span class="pp">#include </span><span class="im">&lt;string&gt;</span></span>
<span id="cb66-5"><a href="#cb66-5" aria-hidden="true"></a></span>
<span id="cb66-6"><a href="#cb66-6" aria-hidden="true"></a><span class="dt">int</span> main() {</span>
<span id="cb66-7"><a href="#cb66-7" aria-hidden="true"></a>    <span class="bu">std::</span>vector&lt;<span class="bu">std::</span>string&gt; name = { <span class="st">&quot;Daniela&quot;</span>, <span class="st">&quot;Jasmine&quot;</span>, <span class="st">&quot;Navarro&quot;</span>, <span class="st">&quot;Bullock&quot;</span> };</span>
<span id="cb66-8"><a href="#cb66-8" aria-hidden="true"></a>    <span class="cf">for</span>(<span class="bu">std::</span>string n : name) { <span class="bu">std::</span>cout &lt;&lt; n &lt;&lt; <span class="bu">std::</span>endl; }</span>
<span id="cb66-9"><a href="#cb66-9" aria-hidden="true"></a>    <span class="cf">return</span> <span class="dv">0</span>;</span>
<span id="cb66-10"><a href="#cb66-10" aria-hidden="true"></a>}</span></code></pre></div>
<pre><code>Daniela
Jasmine
Navarro
Bullock</code></pre>
<h2 id="oop-in-c">OOP in C++</h2>
<p>The next section of the book introduces object oriented programming (OOP) features in C++. At this point I’m about 40 pages in, and now starting to hit material that isn’t already familiar to me. Yay! Time to learn new things!</p>
<p>Some preliminaries:</p>
<ul>
<li>To orient an R user, it’s helpful to note that the OOP model in C++ is qualitatively similar to the “encapsulated OOP” approach taken by R6 classes (the “functional OOP” model in S3 classes is probably more analogous to function overloading in C++).</li>
<li>To write this section of my notes I went a little beyond the book itself, because the book relies on C++20 modules here which don’t seem to be fully supported in clang 15? So this section of my notes is also partly based on <a href="https://www.learncpp.com/cpp-tutorial/class-code-and-header-files/">this tutorial</a>. The traditional structure of a C++ program that defines custom classes is to split the code over three files.</li>
</ul>
<h3 id="an-example">An example</h3>
<p>Okay, after a bit of reading, the basic ideas seem clear:</p>
<ul>
<li>Like most OOP systems, we make a distinction between “public” and “private” fields/methods. Anything private cannot be directly accessed from outside the object. Only the public methods and fields are accessible. This gives us a way of separating the public API for the class from the private data structures used to represent data within an object. C++ also has a “protected” status, which the book defers to later chapters.</li>
<li>Class constructor functions are supported: in C++ the class constructor is a special function that has the same name as the class itself, and doesn’t specify an output type. Function overloading is permitted here.</li>
</ul>
<p>Here’s my first attempt at defining a C++ class. One of my loves in life is gardening, so I’ll define a class <code>Species</code> that stores the taxonomic (binomial) name of a plant, and (optionally) stores the common name. Obviously this is too simple for real world use, because plants often have more than one common name, and the binomial name for a species is often insufficient to represent the taxonomic relations that we might care about. And of course it also fails to capture any of the practical information about a plant! But whatever. That’s not the bloody point. Anyway, here’s the code:</p>
<div class="sourceCode" id="cb68"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb68-1"><a href="#cb68-1" aria-hidden="true"></a><span class="co">// species-first-pass.cpp</span></span>
<span id="cb68-2"><a href="#cb68-2" aria-hidden="true"></a><span class="pp">#include </span><span class="im">&lt;iostream&gt;</span></span>
<span id="cb68-3"><a href="#cb68-3" aria-hidden="true"></a><span class="pp">#include </span><span class="im">&lt;string&gt;</span></span>
<span id="cb68-4"><a href="#cb68-4" aria-hidden="true"></a><span class="pp">#include </span><span class="im">&lt;optional&gt;</span></span>
<span id="cb68-5"><a href="#cb68-5" aria-hidden="true"></a></span>
<span id="cb68-6"><a href="#cb68-6" aria-hidden="true"></a><span class="kw">class</span> Species {</span>
<span id="cb68-7"><a href="#cb68-7" aria-hidden="true"></a>    <span class="kw">private</span>:</span>
<span id="cb68-8"><a href="#cb68-8" aria-hidden="true"></a>        <span class="co">// internal data structure</span></span>
<span id="cb68-9"><a href="#cb68-9" aria-hidden="true"></a>        <span class="bu">std::</span>string name_binomial;</span>
<span id="cb68-10"><a href="#cb68-10" aria-hidden="true"></a>        <span class="bu">std::</span>optional&lt;<span class="bu">std::</span>string&gt; name_common;</span>
<span id="cb68-11"><a href="#cb68-11" aria-hidden="true"></a></span>
<span id="cb68-12"><a href="#cb68-12" aria-hidden="true"></a>    <span class="kw">public</span>:</span>
<span id="cb68-13"><a href="#cb68-13" aria-hidden="true"></a>        <span class="co">// class constructor with one input</span></span>
<span id="cb68-14"><a href="#cb68-14" aria-hidden="true"></a>        Species(<span class="bu">std::</span>string binomial) {</span>
<span id="cb68-15"><a href="#cb68-15" aria-hidden="true"></a>            setBinomialName(binomial);</span>
<span id="cb68-16"><a href="#cb68-16" aria-hidden="true"></a>        }</span>
<span id="cb68-17"><a href="#cb68-17" aria-hidden="true"></a></span>
<span id="cb68-18"><a href="#cb68-18" aria-hidden="true"></a>        <span class="co">// class constructor with two inputs</span></span>
<span id="cb68-19"><a href="#cb68-19" aria-hidden="true"></a>        Species(<span class="bu">std::</span>string binomial, <span class="bu">std::</span>optional&lt;<span class="bu">std::</span>string&gt; common) {</span>
<span id="cb68-20"><a href="#cb68-20" aria-hidden="true"></a>            setBinomialName(binomial);</span>
<span id="cb68-21"><a href="#cb68-21" aria-hidden="true"></a>            setCommonName(common);</span>
<span id="cb68-22"><a href="#cb68-22" aria-hidden="true"></a>        }</span>
<span id="cb68-23"><a href="#cb68-23" aria-hidden="true"></a></span>
<span id="cb68-24"><a href="#cb68-24" aria-hidden="true"></a>        <span class="co">// methods to set names</span></span>
<span id="cb68-25"><a href="#cb68-25" aria-hidden="true"></a>        <span class="dt">void</span> setBinomialName(<span class="bu">std::</span>string name) { name_binomial = name; }</span>
<span id="cb68-26"><a href="#cb68-26" aria-hidden="true"></a>        <span class="dt">void</span> setCommonName(<span class="bu">std::</span>optional&lt;<span class="bu">std::</span>string&gt; name) { name_common = name; }</span>
<span id="cb68-27"><a href="#cb68-27" aria-hidden="true"></a></span>
<span id="cb68-28"><a href="#cb68-28" aria-hidden="true"></a>        <span class="co">// methods to retrieve names</span></span>
<span id="cb68-29"><a href="#cb68-29" aria-hidden="true"></a>        <span class="bu">std::</span>string getBinomialName() { <span class="cf">return</span> name_binomial; }</span>
<span id="cb68-30"><a href="#cb68-30" aria-hidden="true"></a>        <span class="bu">std::</span>optional&lt;<span class="bu">std::</span>string&gt; getCommonName() { <span class="cf">return</span> name_common; }</span>
<span id="cb68-31"><a href="#cb68-31" aria-hidden="true"></a></span>
<span id="cb68-32"><a href="#cb68-32" aria-hidden="true"></a>        <span class="co">// print method</span></span>
<span id="cb68-33"><a href="#cb68-33" aria-hidden="true"></a>        <span class="dt">void</span> print() {</span>
<span id="cb68-34"><a href="#cb68-34" aria-hidden="true"></a>            <span class="bu">std::</span>cout &lt;&lt; name_binomial;</span>
<span id="cb68-35"><a href="#cb68-35" aria-hidden="true"></a>            <span class="cf">if</span> (name_common.has_value()) {</span>
<span id="cb68-36"><a href="#cb68-36" aria-hidden="true"></a>                <span class="bu">std::</span>cout &lt;&lt; <span class="st">&quot; (&quot;</span> &lt;&lt; name_common.value() &lt;&lt; <span class="st">&quot;)&quot;</span>;</span>
<span id="cb68-37"><a href="#cb68-37" aria-hidden="true"></a>            }</span>
<span id="cb68-38"><a href="#cb68-38" aria-hidden="true"></a>            <span class="bu">std::</span>cout &lt;&lt; <span class="bu">std::</span>endl;</span>
<span id="cb68-39"><a href="#cb68-39" aria-hidden="true"></a>        }</span>
<span id="cb68-40"><a href="#cb68-40" aria-hidden="true"></a>};</span>
<span id="cb68-41"><a href="#cb68-41" aria-hidden="true"></a></span>
<span id="cb68-42"><a href="#cb68-42" aria-hidden="true"></a><span class="dt">int</span> main() {</span>
<span id="cb68-43"><a href="#cb68-43" aria-hidden="true"></a>    Species yellow_plant { <span class="st">&quot;acacia amoena&quot;</span> };</span>
<span id="cb68-44"><a href="#cb68-44" aria-hidden="true"></a>    Species purple_plant { <span class="st">&quot;hardenbergia violacea&quot;</span>, <span class="st">&quot;happy wanderer&quot;</span> };</span>
<span id="cb68-45"><a href="#cb68-45" aria-hidden="true"></a>    yellow_plant.print();</span>
<span id="cb68-46"><a href="#cb68-46" aria-hidden="true"></a>    purple_plant.print();</span>
<span id="cb68-47"><a href="#cb68-47" aria-hidden="true"></a>    <span class="cf">return</span> <span class="dv">0</span>;</span>
<span id="cb68-48"><a href="#cb68-48" aria-hidden="true"></a>}</span></code></pre></div>
<p>When I run this program, I get this as the output:</p>
<pre><code>acacia amoena
hardenbergia violacea (happy wanderer)</code></pre>
<p>Neat. The output always prints the binomial name of the species, and appends the common name in parentheses if one exists. Additionally, because the <code>.setCommonName()</code> method is public, should I later happen to discover to my delight that the <em>acacia amoena</em> is commonly referred to as the boomerang wattle, I can update the record like so:</p>
<div class="sourceCode" id="cb70"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb70-1"><a href="#cb70-1" aria-hidden="true"></a>yellow_plant.setCommonName(<span class="st">&quot;boomerang wattle&quot;</span>);</span></code></pre></div>
<p>Fab. Moving on.</p>
<h3 id="separating-class-definition-from-class-methods">Separating class definition from class methods</h3>
<p>The program I wrote above is simple enough that it could probably stay as a single script, but that quickly becomes unworkable for larger programs, especially if the class needs to be make available in multiple parts of the code base. For that reason it’s conventional to define the class using one or more dedicated files, where the file name is identical to the class name. The specific convention seems to be:</p>
<ul>
<li><code>Species.h</code> contains the <strong>class definition</strong></li>
<li><code>Species.cpp</code> defines the <strong>class methods</strong></li>
</ul>
<p>I would then save the source code that actually uses these classes for something as <code>species-second-pass.cpp</code> or whatever, and incorporate the class using <code>#include</code> directives.</p>
<h2 id="scopes">Scopes</h2>
<p>Next up the book discusses C++ scopes. It all feels very familiar. Every variable and function belongs to a scope and is usually visible only within that scope. Examples:</p>
<ul>
<li>Functions define a scope. Variables defined in a function are available only within that function.</li>
<li>Variables deined in the initialiser when using <code>if</code>, <code>switch</code>, or <code>for</code> are scoped to the code block for that loop/conditional.</li>
<li>Class definitions provide scopes: variables defined within a class are scoped to the class.</li>
<li>Curly braces can be used to define a code block, and again variables are scoped to the block.</li>
<li><code>namespace</code> declarations create variables scoped to that namespace. Variables within a namespace can be explicitly referenced from outside the scope using the <code>::</code> operator (which is what I’ve been doing with the <code>std</code> namespace throughout this code)</li>
</ul>
<p>Here’s an adaptation of the example used in the book:</p>
<div class="sourceCode" id="cb71"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb71-1"><a href="#cb71-1" aria-hidden="true"></a><span class="co">// scope-resolution.cpp</span></span>
<span id="cb71-2"><a href="#cb71-2" aria-hidden="true"></a><span class="pp">#include </span><span class="im">&lt;iostream&gt;</span></span>
<span id="cb71-3"><a href="#cb71-3" aria-hidden="true"></a></span>
<span id="cb71-4"><a href="#cb71-4" aria-hidden="true"></a><span class="co">// value() is scoped to the Five class</span></span>
<span id="cb71-5"><a href="#cb71-5" aria-hidden="true"></a><span class="kw">class</span> Five  {</span>
<span id="cb71-6"><a href="#cb71-6" aria-hidden="true"></a>    <span class="kw">public</span>:</span>
<span id="cb71-7"><a href="#cb71-7" aria-hidden="true"></a>        <span class="dt">int</span> value() { <span class="cf">return</span> <span class="dv">5</span>; }</span>
<span id="cb71-8"><a href="#cb71-8" aria-hidden="true"></a>};</span>
<span id="cb71-9"><a href="#cb71-9" aria-hidden="true"></a></span>
<span id="cb71-10"><a href="#cb71-10" aria-hidden="true"></a><span class="co">// value() belongs to the global scope</span></span>
<span id="cb71-11"><a href="#cb71-11" aria-hidden="true"></a><span class="dt">int</span> value() { <span class="cf">return</span> <span class="dv">10</span>; }</span>
<span id="cb71-12"><a href="#cb71-12" aria-hidden="true"></a></span>
<span id="cb71-13"><a href="#cb71-13" aria-hidden="true"></a><span class="co">// value() belongs to the twenty namespace</span></span>
<span id="cb71-14"><a href="#cb71-14" aria-hidden="true"></a><span class="kw">namespace</span> twenty {</span>
<span id="cb71-15"><a href="#cb71-15" aria-hidden="true"></a>    <span class="dt">int</span> value() { <span class="cf">return</span> <span class="dv">20</span>; }</span>
<span id="cb71-16"><a href="#cb71-16" aria-hidden="true"></a>}</span>
<span id="cb71-17"><a href="#cb71-17" aria-hidden="true"></a></span>
<span id="cb71-18"><a href="#cb71-18" aria-hidden="true"></a><span class="dt">int</span> main() {</span>
<span id="cb71-19"><a href="#cb71-19" aria-hidden="true"></a>    Five five;</span>
<span id="cb71-20"><a href="#cb71-20" aria-hidden="true"></a>    <span class="bu">std::</span>cout &lt;&lt; five.value() &lt;&lt; <span class="bu">std::</span>endl;    <span class="co">// prints 5</span></span>
<span id="cb71-21"><a href="#cb71-21" aria-hidden="true"></a>    <span class="bu">std::</span>cout &lt;&lt; value() &lt;&lt; <span class="bu">std::</span>endl;         <span class="co">// prints 10</span></span>
<span id="cb71-22"><a href="#cb71-22" aria-hidden="true"></a>    <span class="bu">std::</span>cout &lt;&lt; twenty::value() &lt;&lt; <span class="bu">std::</span>endl; <span class="co">// prints 20</span></span>
<span id="cb71-23"><a href="#cb71-23" aria-hidden="true"></a>    <span class="cf">return</span> <span class="dv">0</span>;</span>
<span id="cb71-24"><a href="#cb71-24" aria-hidden="true"></a>}</span></code></pre></div>
<pre><code>5
10
20</code></pre>
<h2 id="uniform-initialisation">Uniform initialisation</h2>
<p>In early versions of C++, variable initialisation statements looked different depending on what kind of object is being initialised. Since C++11, however, uniform initialisation has been available so you can initialise variables using the same syntax regardless of type. The book gives the following example:</p>
<div class="sourceCode" id="cb73"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb73-1"><a href="#cb73-1" aria-hidden="true"></a><span class="co">// circles.cpp</span></span>
<span id="cb73-2"><a href="#cb73-2" aria-hidden="true"></a></span>
<span id="cb73-3"><a href="#cb73-3" aria-hidden="true"></a><span class="kw">struct</span> CircleStruct {</span>
<span id="cb73-4"><a href="#cb73-4" aria-hidden="true"></a>    <span class="dt">int</span> x, y;</span>
<span id="cb73-5"><a href="#cb73-5" aria-hidden="true"></a>    <span class="dt">double</span> radius;</span>
<span id="cb73-6"><a href="#cb73-6" aria-hidden="true"></a>};</span>
<span id="cb73-7"><a href="#cb73-7" aria-hidden="true"></a></span>
<span id="cb73-8"><a href="#cb73-8" aria-hidden="true"></a><span class="kw">class</span> CircleClass {</span>
<span id="cb73-9"><a href="#cb73-9" aria-hidden="true"></a>    <span class="kw">public</span>:</span>
<span id="cb73-10"><a href="#cb73-10" aria-hidden="true"></a>        CircleClass(<span class="dt">int</span> x, <span class="dt">int</span> y, <span class="dt">double</span> radius) </span>
<span id="cb73-11"><a href="#cb73-11" aria-hidden="true"></a>            : <span class="va">m_x</span> { x }, <span class="va">m_y</span> { y }, <span class="va">m_radius</span> { radius } {}</span>
<span id="cb73-12"><a href="#cb73-12" aria-hidden="true"></a>    <span class="kw">private</span>:</span>
<span id="cb73-13"><a href="#cb73-13" aria-hidden="true"></a>        <span class="dt">int</span> <span class="va">m_x</span>, <span class="va">m_y</span>;</span>
<span id="cb73-14"><a href="#cb73-14" aria-hidden="true"></a>        <span class="dt">double</span> <span class="va">m_radius</span>;</span>
<span id="cb73-15"><a href="#cb73-15" aria-hidden="true"></a>};</span>
<span id="cb73-16"><a href="#cb73-16" aria-hidden="true"></a></span>
<span id="cb73-17"><a href="#cb73-17" aria-hidden="true"></a><span class="dt">int</span> main() {</span>
<span id="cb73-18"><a href="#cb73-18" aria-hidden="true"></a>    <span class="co">// these both use uniform initialisation</span></span>
<span id="cb73-19"><a href="#cb73-19" aria-hidden="true"></a>    CircleStruct circle1 { <span class="dv">10</span>, <span class="dv">10</span>, <span class="fl">2.5</span> };</span>
<span id="cb73-20"><a href="#cb73-20" aria-hidden="true"></a>    CircleClass circle2 { <span class="dv">10</span>, <span class="dv">10</span>, <span class="fl">2.5</span>};</span>
<span id="cb73-21"><a href="#cb73-21" aria-hidden="true"></a></span>
<span id="cb73-22"><a href="#cb73-22" aria-hidden="true"></a>    <span class="co">// pre C++11, you had to do this:</span></span>
<span id="cb73-23"><a href="#cb73-23" aria-hidden="true"></a>    CircleStruct circle3 = { <span class="dv">10</span>, <span class="dv">10</span>, <span class="fl">2.5</span> };</span>
<span id="cb73-24"><a href="#cb73-24" aria-hidden="true"></a>    CircleClass circle4(<span class="dv">10</span>, <span class="dv">10</span>, <span class="fl">2.5</span>);</span>
<span id="cb73-25"><a href="#cb73-25" aria-hidden="true"></a></span>
<span id="cb73-26"><a href="#cb73-26" aria-hidden="true"></a>    <span class="co">// note that this is not uniform initialisation</span></span>
<span id="cb73-27"><a href="#cb73-27" aria-hidden="true"></a>    <span class="dt">int</span> a = <span class="dv">3</span>;</span>
<span id="cb73-28"><a href="#cb73-28" aria-hidden="true"></a>    <span class="dt">int</span> b(<span class="dv">3</span>);</span>
<span id="cb73-29"><a href="#cb73-29" aria-hidden="true"></a></span>
<span id="cb73-30"><a href="#cb73-30" aria-hidden="true"></a>    <span class="co">// these are both uniform</span></span>
<span id="cb73-31"><a href="#cb73-31" aria-hidden="true"></a>    <span class="dt">int</span> c = { <span class="dv">3</span> };</span>
<span id="cb73-32"><a href="#cb73-32" aria-hidden="true"></a>    <span class="dt">int</span> d { <span class="dv">3</span>};</span>
<span id="cb73-33"><a href="#cb73-33" aria-hidden="true"></a></span>
<span id="cb73-34"><a href="#cb73-34" aria-hidden="true"></a>    <span class="cf">return</span> <span class="dv">0</span>;</span>
<span id="cb73-35"><a href="#cb73-35" aria-hidden="true"></a>}</span></code></pre></div>
<p>There are some subtle differences between uniform and non-uniform initialisation, particularly in reference to <strong>narrowing</strong>. In old style initialisation, this works…</p>
<div class="sourceCode" id="cb74"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb74-1"><a href="#cb74-1" aria-hidden="true"></a><span class="dt">int</span> x = <span class="fl">3.14</span>;</span></code></pre></div>
<p>but because <code>x</code> is an integer the value stored is <code>3</code>. This is the narrowing phenomenon. If you use uniform initialisation, narrowing is forbidden. This produces a compiler error:</p>
<div class="sourceCode" id="cb75"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb75-1"><a href="#cb75-1" aria-hidden="true"></a><span class="dt">int</span> x { <span class="fl">3.14</span> };</span></code></pre></div>
<p>There are tools to explicitly perform narrowing if that’s what’s needed: the book mentions the <code>gsl::narrow_cast()</code> function in the Guidelines Support Library (GSL).</p>
<p>In general, the book recommends uniform initialisation.</p>
<h2 id="pointers-and-dynamic-memory">Pointers and dynamic memory</h2>
<p>Notes on memory management in C++. There are two different kinds of memory allocation in C++: the <strong>stack</strong> and the <strong>free store</strong>. The metaphor used to describe the stack is a “deck of cards”. The top “card” (or, <strong>stack frame</strong>) represents the current scope (e.g., function currently being executed). Variables declared within that scope are stored in this stack frame. Parameters passed to a function call are copied into the stack associated with the function scope. When the scope goes away (e.g., function completes), so too does the corresponding stack frame. Variables allocated to stack memory don’t require any special management: C++ automatically takes care of the allocation and deallocation of memory.</p>
<p>The free store is different. It corresponds to an area of memory that is independent of the stack, and you can place variables there that will persist even when the scope in which they were declared goes away. Memory on the free store needs to be manually managed: it has no notion of frames, and there is no automatic deallocation. (…Unless, apparently, you use smart pointers, which the book foreshadows will be discussed later).</p>
<h3 id="pointers-to-free-store-variables">Pointers to free store variables</h3>
<p>Okay, so… noting that smart pointers are coming later in the book, I think all I’ll do here is quickly summarise the key things. If you want to place an integer on the free store, we first declare a <strong>pointer</strong>. A pointer is a reference to a location in memory. So when I do this:</p>
<div class="sourceCode" id="cb76"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb76-1"><a href="#cb76-1" aria-hidden="true"></a><span class="dt">int</span>* my_int_pointer { <span class="kw">nullptr</span> };</span></code></pre></div>
<p>what I’m doing is specifying that <code>my_int_pointer</code> is going to reference the location of an integer value (the <code>*</code> in <code>int*</code> indicates that a pointer is being declared). At this stage, the pointer doesn’t actually reference a specific location: the <code>nullptr</code> (“null pointer”) value is a special value that doesn’t correspond to a valid location, and evaluates to <code>false</code> if used in a logical expression.</p>
<p>To allocate the memory and have the pointer reference that location in memory, we use <code>new</code>:</p>
<div class="sourceCode" id="cb77"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb77-1"><a href="#cb77-1" aria-hidden="true"></a>my_int_pointer = <span class="kw">new</span> <span class="dt">int</span>;</span></code></pre></div>
<p>At this stage, a block of memory has been allocated for the integer and <code>my_int_pointer</code> now references that location. To access that location, either to retrieve the value or assign a value to it, we <strong>dereference</strong> the pointer:</p>
<div class="sourceCode" id="cb78"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb78-1"><a href="#cb78-1" aria-hidden="true"></a>*my_int_pointer = <span class="dv">8</span>;</span></code></pre></div>
<p>My example program:</p>
<div class="sourceCode" id="cb79"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb79-1"><a href="#cb79-1" aria-hidden="true"></a><span class="co">// pointer-free-store.cpp</span></span>
<span id="cb79-2"><a href="#cb79-2" aria-hidden="true"></a><span class="pp">#include </span><span class="im">&lt;iostream&gt;</span></span>
<span id="cb79-3"><a href="#cb79-3" aria-hidden="true"></a></span>
<span id="cb79-4"><a href="#cb79-4" aria-hidden="true"></a><span class="dt">int</span> main() {</span>
<span id="cb79-5"><a href="#cb79-5" aria-hidden="true"></a>    <span class="dt">int</span>* int_ptr { <span class="kw">new</span> <span class="dt">int</span> }; <span class="co">// declare pointer &amp; allocate memory</span></span>
<span id="cb79-6"><a href="#cb79-6" aria-hidden="true"></a>    *int_ptr = <span class="dv">8</span>;             <span class="co">// assign value to the allocated memory</span></span>
<span id="cb79-7"><a href="#cb79-7" aria-hidden="true"></a>    <span class="bu">std::</span>cout &lt;&lt; *int_ptr + <span class="dv">2</span> &lt;&lt; <span class="bu">std::</span>endl; <span class="co">// retrieve and print</span></span>
<span id="cb79-8"><a href="#cb79-8" aria-hidden="true"></a>    <span class="cf">return</span> <span class="dv">0</span>;</span>
<span id="cb79-9"><a href="#cb79-9" aria-hidden="true"></a>}</span></code></pre></div>
<p>When executed, it prints 10 to stdout.</p>
<h3 id="pointers-to-stack-variables">Pointers to stack variables</h3>
<p>C++ also allows pointers to variables on the stack (and even pointers to pointers, but whatever). The key thing here is to use <code>&amp;</code> (“address of”) to return a pointer to a stack-allocated variable. So this works and also prints 10 to stdout:</p>
<div class="sourceCode" id="cb80"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb80-1"><a href="#cb80-1" aria-hidden="true"></a><span class="co">// pointer-stack.cpp</span></span>
<span id="cb80-2"><a href="#cb80-2" aria-hidden="true"></a><span class="pp">#include </span><span class="im">&lt;iostream&gt;</span></span>
<span id="cb80-3"><a href="#cb80-3" aria-hidden="true"></a></span>
<span id="cb80-4"><a href="#cb80-4" aria-hidden="true"></a><span class="dt">int</span> main() {</span>
<span id="cb80-5"><a href="#cb80-5" aria-hidden="true"></a>    <span class="dt">int</span> value { <span class="dv">8</span> };          <span class="co">// variable on the stack</span></span>
<span id="cb80-6"><a href="#cb80-6" aria-hidden="true"></a>    <span class="dt">int</span>* int_ptr { &amp;value };  <span class="co">// declare pointer to it</span></span>
<span id="cb80-7"><a href="#cb80-7" aria-hidden="true"></a>    <span class="bu">std::</span>cout &lt;&lt; *int_ptr + <span class="dv">2</span> &lt;&lt; <span class="bu">std::</span>endl; <span class="co">// retrieve and print</span></span>
<span id="cb80-8"><a href="#cb80-8" aria-hidden="true"></a>    <span class="cf">return</span> <span class="dv">0</span>;</span>
<span id="cb80-9"><a href="#cb80-9" aria-hidden="true"></a>}</span></code></pre></div>
<h3 id="pointers-to-structs-and-classes">Pointers to structs and classes</h3>
<p>There’s a little bit of syntactic sugar for pointers to structs and classes. Copying the code directly from the book. Assume there’s a function <code>getEmployee()</code> that returns a pointer to an <code>Employee</code> instance. Then we could write the salary to stdout like so:</p>
<div class="sourceCode" id="cb81"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb81-1"><a href="#cb81-1" aria-hidden="true"></a>Employee* anEmployee { getEmployee() }; </span>
<span id="cb81-2"><a href="#cb81-2" aria-hidden="true"></a><span class="bu">std::</span>cout &lt;&lt; (*anEmployee).salary &lt;&lt; <span class="bu">std::</span>cout;</span></code></pre></div>
<p>The <code>-&gt;</code> operator allows a shortcut:</p>
<div class="sourceCode" id="cb82"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb82-1"><a href="#cb82-1" aria-hidden="true"></a>Employee* anEmployee { getEmployee() }; </span>
<span id="cb82-2"><a href="#cb82-2" aria-hidden="true"></a><span class="bu">std::</span>cout &lt;&lt; anEmployee-&gt;salary &lt;&lt; <span class="bu">std::</span>cout;</span></code></pre></div>
<p>Okay fair enough. Moving on.</p>
<h3 id="dynamically-allocated-arrays">Dynamically allocated arrays</h3>
<p>The book here has a short section on dynamically allocated arrays, but I’m going to skip over that for now. The main thing is that it advises not to use <code>malloc()</code> and <code>free()</code> from C for this, and instead use <code>new</code> and <code>delete</code> or <code>new[]</code> and <code>delete[]</code>. Noted :-)</p>
<h2 id="the-const-keyword">The <code>const</code> keyword</h2>
<p>The <code>const</code> keyword is used to indicate that something is not permitted to change within the program. It can be used in a few ways. The simplest case is declaring that the value of a variable must not be changed:</p>
<div class="sourceCode" id="cb83"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb83-1"><a href="#cb83-1" aria-hidden="true"></a><span class="at">const</span> <span class="dt">int</span> versionNumberMajor { <span class="dv">2</span> };</span>
<span id="cb83-2"><a href="#cb83-2" aria-hidden="true"></a><span class="at">const</span> <span class="dt">int</span> versionNumberMinor { <span class="dv">1</span> };</span>
<span id="cb83-3"><a href="#cb83-3" aria-hidden="true"></a><span class="at">const</span> str::string productName { <span class="st">&quot;My fabulous product&quot;</span> };</span></code></pre></div>
<p>The same idea can be applied to pointers:</p>
<div class="sourceCode" id="cb84"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb84-1"><a href="#cb84-1" aria-hidden="true"></a><span class="co">// the pointed-to value cannot be changed</span></span>
<span id="cb84-2"><a href="#cb84-2" aria-hidden="true"></a><span class="at">const</span> <span class="dt">int</span>* ptr; </span>
<span id="cb84-3"><a href="#cb84-3" aria-hidden="true"></a><span class="dt">int</span> <span class="at">const</span>* ptr; <span class="co">// same meaning</span></span>
<span id="cb84-4"><a href="#cb84-4" aria-hidden="true"></a></span>
<span id="cb84-5"><a href="#cb84-5" aria-hidden="true"></a><span class="co">// the pointer itself cannot be changed</span></span>
<span id="cb84-6"><a href="#cb84-6" aria-hidden="true"></a><span class="dt">int</span>* <span class="at">const</span> ptr { <span class="kw">nullptr</span> }; </span>
<span id="cb84-7"><a href="#cb84-7" aria-hidden="true"></a>ptr = <span class="kw">new</span> <span class="dt">int</span>; <span class="co">// this won&#39;t compile</span></span>
<span id="cb84-8"><a href="#cb84-8" aria-hidden="true"></a></span>
<span id="cb84-9"><a href="#cb84-9" aria-hidden="true"></a><span class="co">// the pointer itself cannot be changed</span></span>
<span id="cb84-10"><a href="#cb84-10" aria-hidden="true"></a><span class="dt">int</span>* <span class="at">const</span> ptr { <span class="kw">new</span> <span class="dt">int</span>[<span class="dv">10</span>] };</span></code></pre></div>
<p>You can also do things like this:</p>
<div class="sourceCode" id="cb85"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb85-1"><a href="#cb85-1" aria-hidden="true"></a><span class="dt">void</span> func(<span class="at">const</span> <span class="dt">int</span> param) {</span>
<span id="cb85-2"><a href="#cb85-2" aria-hidden="true"></a>    <span class="co">// this code cannot change the value of param</span></span>
<span id="cb85-3"><a href="#cb85-3" aria-hidden="true"></a>}</span></code></pre></div>
<p>You can also use <code>const</code> to declare that certain methods of a class are not permitted to change the member data. So the relevant bit of the code might look like this:</p>
<div class="sourceCode" id="cb86"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb86-1"><a href="#cb86-1" aria-hidden="true"></a><span class="kw">public</span>: </span>
<span id="cb86-2"><a href="#cb86-2" aria-hidden="true"></a>    <span class="dt">int</span> methodToComputeSomething() <span class="at">const</span>; <span class="co">// cannot modify internal data</span></span>
<span id="cb86-3"><a href="#cb86-3" aria-hidden="true"></a>    <span class="dt">void</span> methodToSetInternalData();       <span class="co">// can modifiy internal data</span></span></code></pre></div>
<p>It’s generally considered best practice to follow the “const correctness” principle, and always declare member functions that do not change any data members as <code>const</code>. The terminology here is:</p>
<ul>
<li>A <code>const</code> member function, which cannot modify data, is called an <strong>inspector</strong></li>
<li>A non-<code>const</code> member function, which does modify data, is called a <strong>mutator</strong></li>
</ul>
<h2 id="references">References</h2>
<p>A <strong>reference</strong> is an alias for another variable: essentially another name given to the same object. Changes to the reference variable are reflected in the original variable, and vice versa. The mental model suggested in the book is that you can think of references as implicit pointers, where you don’t have to take care of addressing and dereferencing yourself. Declaring the reference variable is done using <code>&amp;</code>, like this:</p>
<div class="sourceCode" id="cb87"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb87-1"><a href="#cb87-1" aria-hidden="true"></a><span class="dt">int</span> x { <span class="dv">10</span> };      <span class="co">// original variable</span></span>
<span id="cb87-2"><a href="#cb87-2" aria-hidden="true"></a><span class="dt">int</span>&amp; x_ref { x };  <span class="co">// reference variable</span></span></code></pre></div>
<p>The equivalence of the original and the reference is illustrated in this simple program:</p>
<div class="sourceCode" id="cb88"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb88-1"><a href="#cb88-1" aria-hidden="true"></a><span class="co">// simple-reference.cpp</span></span>
<span id="cb88-2"><a href="#cb88-2" aria-hidden="true"></a><span class="pp">#include </span><span class="im">&lt;iostream&gt;</span></span>
<span id="cb88-3"><a href="#cb88-3" aria-hidden="true"></a></span>
<span id="cb88-4"><a href="#cb88-4" aria-hidden="true"></a><span class="dt">int</span> main() {</span>
<span id="cb88-5"><a href="#cb88-5" aria-hidden="true"></a>    <span class="dt">int</span> x { <span class="dv">10</span> };     <span class="co">// original </span></span>
<span id="cb88-6"><a href="#cb88-6" aria-hidden="true"></a>    <span class="dt">int</span>&amp; x_ref { x }; <span class="co">// reference</span></span>
<span id="cb88-7"><a href="#cb88-7" aria-hidden="true"></a></span>
<span id="cb88-8"><a href="#cb88-8" aria-hidden="true"></a>    x_ref++; <span class="co">// change the reference, *and* the original</span></span>
<span id="cb88-9"><a href="#cb88-9" aria-hidden="true"></a>    <span class="bu">std::</span>cout &lt;&lt; x &lt;&lt; <span class="bu">std::</span>endl; <span class="co">// prints 11</span></span>
<span id="cb88-10"><a href="#cb88-10" aria-hidden="true"></a></span>
<span id="cb88-11"><a href="#cb88-11" aria-hidden="true"></a>    x++; <span class="co">// change the original, *and* the reference</span></span>
<span id="cb88-12"><a href="#cb88-12" aria-hidden="true"></a>    <span class="bu">std::</span>cout &lt;&lt; x_ref &lt;&lt; <span class="bu">std::</span>endl; <span class="co">// prints 12</span></span>
<span id="cb88-13"><a href="#cb88-13" aria-hidden="true"></a>    </span>
<span id="cb88-14"><a href="#cb88-14" aria-hidden="true"></a>    <span class="cf">return</span> <span class="dv">0</span>;</span>
<span id="cb88-15"><a href="#cb88-15" aria-hidden="true"></a>}</span></code></pre></div>
<p>References must always be initialised when declared. This won’t compile:</p>
<div class="sourceCode" id="cb89"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb89-1"><a href="#cb89-1" aria-hidden="true"></a><span class="dt">int</span>&amp; empty_ref; </span></code></pre></div>
<p>Along similar lines, you cannot change the mapping once a reference variable is initialised (i.e., it always refers to the same original variable, and you can’t move it to a new one). This is illustrated in this program:</p>
<div class="sourceCode" id="cb90"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb90-1"><a href="#cb90-1" aria-hidden="true"></a><span class="co">// immovable-reference.cpp</span></span>
<span id="cb90-2"><a href="#cb90-2" aria-hidden="true"></a><span class="pp">#include </span><span class="im">&lt;iostream&gt;</span></span>
<span id="cb90-3"><a href="#cb90-3" aria-hidden="true"></a></span>
<span id="cb90-4"><a href="#cb90-4" aria-hidden="true"></a><span class="dt">int</span> main() {</span>
<span id="cb90-5"><a href="#cb90-5" aria-hidden="true"></a>    <span class="dt">int</span> x { <span class="dv">3</span> };</span>
<span id="cb90-6"><a href="#cb90-6" aria-hidden="true"></a>    <span class="dt">int</span> y { <span class="dv">4</span> };</span>
<span id="cb90-7"><a href="#cb90-7" aria-hidden="true"></a></span>
<span id="cb90-8"><a href="#cb90-8" aria-hidden="true"></a>    <span class="dt">int</span>&amp; x_ref { x };</span>
<span id="cb90-9"><a href="#cb90-9" aria-hidden="true"></a>    x_ref = y;  <span class="co">// changes the value of x to match y</span></span>
<span id="cb90-10"><a href="#cb90-10" aria-hidden="true"></a>    <span class="bu">std::</span>cout &lt;&lt; x &lt;&lt; <span class="bu">std::</span>endl;</span>
<span id="cb90-11"><a href="#cb90-11" aria-hidden="true"></a></span>
<span id="cb90-12"><a href="#cb90-12" aria-hidden="true"></a>    <span class="cf">return</span> <span class="dv">0</span>;</span>
<span id="cb90-13"><a href="#cb90-13" aria-hidden="true"></a>}</span></code></pre></div>
<h3 id="reference-to-const">Reference-to-const</h3>
<p>You are allowed to specify a “reference to const”, as illustrated in the second line of the code snippet below:</p>
<div class="sourceCode" id="cb91"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb91-1"><a href="#cb91-1" aria-hidden="true"></a><span class="dt">double</span> val { <span class="fl">1.234</span> }; <span class="co">// ok</span></span>
<span id="cb91-2"><a href="#cb91-2" aria-hidden="true"></a><span class="at">const</span> <span class="dt">double</span>&amp; val_ref_const { val }; <span class="co">// ok</span></span></code></pre></div>
<p>The creates something akin to a “read only” reference. You can access the value of <code>val</code> by using <code>val_ref_const</code>, and you can change the value of both by modifying <code>val</code>:</p>
<div class="sourceCode" id="cb92"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb92-1"><a href="#cb92-1" aria-hidden="true"></a>val = <span class="fl">2.345</span>; <span class="co">// ok, changes val and val_ref_const</span></span></code></pre></div>
<p>What you can’t do, however, is change the value of <code>val</code> by modifying <code>val_ref_const</code>:</p>
<div class="sourceCode" id="cb93"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb93-1"><a href="#cb93-1" aria-hidden="true"></a>val_ref_const = <span class="fl">3.456</span>; <span class="co">// fails, does not compile</span></span></code></pre></div>
<p>This turns out to be super helpful when passing by reference.</p>
<h3 id="pass-by-reference-semantics">Pass-by-reference semantics</h3>
<p>The main use for references is to avoid making copies of values when passing arguments to a function. You could do this with pointers, of course, but pointers are messier, so it’s generally better to do it with references. There can be performance gains by not making unnecessary copies, but there are also other neat things you can do:</p>
<div class="sourceCode" id="cb94"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb94-1"><a href="#cb94-1" aria-hidden="true"></a><span class="co">// swap.cpp</span></span>
<span id="cb94-2"><a href="#cb94-2" aria-hidden="true"></a><span class="pp">#include </span><span class="im">&lt;iostream&gt;</span></span>
<span id="cb94-3"><a href="#cb94-3" aria-hidden="true"></a></span>
<span id="cb94-4"><a href="#cb94-4" aria-hidden="true"></a><span class="dt">void</span> swap(<span class="dt">int</span>&amp; first, <span class="dt">int</span>&amp; second) {</span>
<span id="cb94-5"><a href="#cb94-5" aria-hidden="true"></a>    <span class="dt">int</span> temp { first };</span>
<span id="cb94-6"><a href="#cb94-6" aria-hidden="true"></a>    first = second; </span>
<span id="cb94-7"><a href="#cb94-7" aria-hidden="true"></a>    second = temp;</span>
<span id="cb94-8"><a href="#cb94-8" aria-hidden="true"></a>}</span>
<span id="cb94-9"><a href="#cb94-9" aria-hidden="true"></a></span>
<span id="cb94-10"><a href="#cb94-10" aria-hidden="true"></a><span class="dt">int</span> main() {</span>
<span id="cb94-11"><a href="#cb94-11" aria-hidden="true"></a>    <span class="dt">int</span> x { <span class="dv">10</span> }, y { <span class="dv">20</span> };</span>
<span id="cb94-12"><a href="#cb94-12" aria-hidden="true"></a>    <span class="bu">std::</span>cout &lt;&lt; <span class="st">&quot;original x value is &quot;</span> &lt;&lt; x &lt;&lt; <span class="bu">std::</span>endl;</span>
<span id="cb94-13"><a href="#cb94-13" aria-hidden="true"></a>    <span class="bu">std::</span>cout &lt;&lt; <span class="st">&quot;original y value is &quot;</span> &lt;&lt; y &lt;&lt; <span class="bu">std::</span>endl;</span>
<span id="cb94-14"><a href="#cb94-14" aria-hidden="true"></a>    swap(x, y);</span>
<span id="cb94-15"><a href="#cb94-15" aria-hidden="true"></a>    <span class="bu">std::</span>cout &lt;&lt; <span class="st">&quot;swapped x is now &quot;</span> &lt;&lt; x &lt;&lt; <span class="bu">std::</span>endl;</span>
<span id="cb94-16"><a href="#cb94-16" aria-hidden="true"></a>    <span class="bu">std::</span>cout &lt;&lt; <span class="st">&quot;swapped y is now &quot;</span> &lt;&lt; y &lt;&lt; <span class="bu">std::</span>endl;</span>
<span id="cb94-17"><a href="#cb94-17" aria-hidden="true"></a></span>
<span id="cb94-18"><a href="#cb94-18" aria-hidden="true"></a>    <span class="cf">return</span> <span class="dv">0</span>;</span>
<span id="cb94-19"><a href="#cb94-19" aria-hidden="true"></a>}</span></code></pre></div>
<pre><code>original x value is 10
original y value is 20
swapped x is now 20
swapped y is now 10</code></pre>
<p>Notice that when passing a reference, it’s possible to modify the original variables (outside the scope of the function) by performing operations on the references. That was a handy feature in the <code>swap()</code> example, but normally it’s undesirable. A more typical scenario is one in which you <em>don’t</em> want the function to possess the ability to modify the out-of-scope variables that have been passed through the function arguments (because the only reason you’ve chosen to pass-by-reference rather than pass-by-value is to avoid making copies). In this situation, the best bet is to pass-by-reference-to-const. Because the reference-to-const cannot modify the original variable, it is now impossible for the function to accidentally modify the originals.</p>
<p>Here’s the idea:</p>
<div class="sourceCode" id="cb96"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb96-1"><a href="#cb96-1" aria-hidden="true"></a><span class="co">// pass-by-reference-to-const.cpp</span></span>
<span id="cb96-2"><a href="#cb96-2" aria-hidden="true"></a><span class="pp">#include </span><span class="im">&lt;iostream&gt;</span></span>
<span id="cb96-3"><a href="#cb96-3" aria-hidden="true"></a><span class="pp">#include </span><span class="im">&lt;string&gt;</span></span>
<span id="cb96-4"><a href="#cb96-4" aria-hidden="true"></a></span>
<span id="cb96-5"><a href="#cb96-5" aria-hidden="true"></a><span class="co">// str_print() declares a reference-to-const as the argument</span></span>
<span id="cb96-6"><a href="#cb96-6" aria-hidden="true"></a><span class="dt">void</span> str_print(<span class="at">const</span> <span class="bu">std::</span>string&amp; x) {</span>
<span id="cb96-7"><a href="#cb96-7" aria-hidden="true"></a>    <span class="bu">std::</span>cout &lt;&lt; x &lt;&lt; <span class="bu">std::</span>endl;</span>
<span id="cb96-8"><a href="#cb96-8" aria-hidden="true"></a>}</span>
<span id="cb96-9"><a href="#cb96-9" aria-hidden="true"></a></span>
<span id="cb96-10"><a href="#cb96-10" aria-hidden="true"></a><span class="dt">int</span> main() {</span>
<span id="cb96-11"><a href="#cb96-11" aria-hidden="true"></a>    <span class="bu">std::</span>string str { <span class="st">&quot;hello cruel world&quot;</span> }; </span>
<span id="cb96-12"><a href="#cb96-12" aria-hidden="true"></a>    str_print( str ); <span class="co">// passing a string variable works</span></span>
<span id="cb96-13"><a href="#cb96-13" aria-hidden="true"></a>    str_print( <span class="st">&quot;goodbye cruel world&quot;</span> ); <span class="co">// so does passing a literal</span></span>
<span id="cb96-14"><a href="#cb96-14" aria-hidden="true"></a>    <span class="cf">return</span> <span class="dv">0</span>;</span>
<span id="cb96-15"><a href="#cb96-15" aria-hidden="true"></a>}</span></code></pre></div>
<pre><code>hello cruel world
goodbye cruel world</code></pre>
<h2 id="exception-handling">Exception handling</h2>
<p>The <code>divide()</code> function in this code throws an invalid-argument exception if the denominator is zero. The code within <code>main()</code> implements a try-catch block to handle such an exception if thrown:</p>
<div class="sourceCode" id="cb98"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb98-1"><a href="#cb98-1" aria-hidden="true"></a><span class="co">// try-catch.cpp</span></span>
<span id="cb98-2"><a href="#cb98-2" aria-hidden="true"></a><span class="pp">#include </span><span class="im">&lt;iostream&gt;</span></span>
<span id="cb98-3"><a href="#cb98-3" aria-hidden="true"></a><span class="pp">#include </span><span class="im">&lt;stdexcept&gt;</span></span>
<span id="cb98-4"><a href="#cb98-4" aria-hidden="true"></a></span>
<span id="cb98-5"><a href="#cb98-5" aria-hidden="true"></a><span class="co">// a divide() function that throws an error for divide-by-zero</span></span>
<span id="cb98-6"><a href="#cb98-6" aria-hidden="true"></a><span class="dt">double</span> divide(<span class="dt">double</span> numerator, <span class="dt">double</span> denominator) {</span>
<span id="cb98-7"><a href="#cb98-7" aria-hidden="true"></a>    <span class="cf">if</span> (denominator == <span class="dv">0</span>) {</span>
<span id="cb98-8"><a href="#cb98-8" aria-hidden="true"></a>        <span class="cf">throw</span> <span class="bu">std::</span>invalid_argument { <span class="st">&quot;Denominator cannot be 0.&quot;</span> };</span>
<span id="cb98-9"><a href="#cb98-9" aria-hidden="true"></a>    }</span>
<span id="cb98-10"><a href="#cb98-10" aria-hidden="true"></a>    <span class="cf">return</span> numerator / denominator; </span>
<span id="cb98-11"><a href="#cb98-11" aria-hidden="true"></a>}</span>
<span id="cb98-12"><a href="#cb98-12" aria-hidden="true"></a></span>
<span id="cb98-13"><a href="#cb98-13" aria-hidden="true"></a><span class="dt">int</span> main() {</span>
<span id="cb98-14"><a href="#cb98-14" aria-hidden="true"></a>    <span class="cf">try</span> {</span>
<span id="cb98-15"><a href="#cb98-15" aria-hidden="true"></a>        <span class="bu">std::</span>cout &lt;&lt; divide(<span class="dv">13</span>, <span class="dv">2</span>) &lt;&lt; <span class="bu">std::</span>endl;</span>
<span id="cb98-16"><a href="#cb98-16" aria-hidden="true"></a>        <span class="bu">std::</span>cout &lt;&lt; divide(<span class="dv">13</span>, <span class="dv">0</span>) &lt;&lt; <span class="bu">std::</span>endl;</span>
<span id="cb98-17"><a href="#cb98-17" aria-hidden="true"></a>        <span class="bu">std::</span>cout &lt;&lt; divide(<span class="dv">13</span>, <span class="dv">3</span>) &lt;&lt; <span class="bu">std::</span>endl;</span>
<span id="cb98-18"><a href="#cb98-18" aria-hidden="true"></a>    } <span class="cf">catch</span> (<span class="at">const</span> <span class="bu">std::</span>invalid_argument&amp; exception) {</span>
<span id="cb98-19"><a href="#cb98-19" aria-hidden="true"></a>        <span class="bu">std::</span>cout &lt;&lt; <span class="st">&quot;Exception caught: &quot;</span> &lt;&lt; exception.what() &lt;&lt; <span class="bu">std::</span>endl;</span>
<span id="cb98-20"><a href="#cb98-20" aria-hidden="true"></a>    }</span>
<span id="cb98-21"><a href="#cb98-21" aria-hidden="true"></a>    <span class="cf">return</span> <span class="dv">0</span>;</span>
<span id="cb98-22"><a href="#cb98-22" aria-hidden="true"></a>}</span></code></pre></div>
<pre><code>6.5
Exception caught: Denominator cannot be 0.</code></pre>
<p>Note that when the exception is thrown the <code>try</code> code block immediately terminates and is passed to the <code>catch</code> code block. The third division is never attempted.</p>
<h2 id="additional-sections">Additional sections</h2>
<p>The final sections in the chapter discuss the <code>auto</code> keyword and the <code>decltype</code> keyword, before finishing with an example of a bigger C++ program. For now I’m going to skip those in these notes and move onto the next chapter.</p>
<p><a href="index.html">Back to top</a></p></div>
            <div class="d-none d-xl-block col-xl-2 bd-toc">
               <ul class="section-nav">
                  <li class="toc-entry"><ul>
<li><a href="#the-hello-world-program">The hello world program</a></li>
<li><a href="#compiling-helloworld.cpp">Compiling helloworld.cpp</a></li>
<li><a href="#notes-on-helloworld.cpp">Notes on helloworld.cpp</a></li>
<li><a href="#variables-types-and-operators">Variables, types, and operators</a></li>
<li><a href="#casting-and-coercion">Casting and coercion</a></li>
<li><a href="#enumerated-types">Enumerated types</a></li>
<li><a href="#structs">Structs</a></li>
<li><a href="#digression-poisson-variates">Digression: Poisson variates</a></li>
<li><a href="#conditionals">Conditionals</a></li>
<li><a href="#logical-expressions">Logical expressions</a></li>
<li><a href="#functions">Functions</a></li>
<li><a href="#arrays">Arrays</a></li>
<li><a href="#vectors">Vectors</a></li>
<li><a href="#pairs-and-optionals">Pairs and optionals</a></li>
<li><a href="#structured-bindings">Structured bindings</a></li>
<li><a href="#loops">Loops</a></li>
<li><a href="#initialiser-lists">Initialiser lists</a></li>
<li><a href="#strings">Strings</a></li>
<li><a href="#oop-in-c">OOP in C++</a></li>
<li><a href="#scopes">Scopes</a></li>
<li><a href="#uniform-initialisation">Uniform initialisation</a></li>
<li><a href="#pointers-and-dynamic-memory">Pointers and dynamic memory</a></li>
<li><a href="#the-const-keyword">The <code>const</code> keyword</a></li>
<li><a href="#references">References</a></li>
<li><a href="#exception-handling">Exception handling</a></li>
<li><a href="#additional-sections">Additional sections</a></li>
</ul></li>
               </ul>
            </div>
         </div>
               </div>
            <!-- JS, Popper.js, and jQuery -->
      <script src="https://code.jquery.com/jquery-3.5.1.slim.min.js" integrity="sha384-DfXdz2htPH0lsSSs5nCTpuj/zy4C+OGpamoFVy38MVBnE+IbbVYUew+OrCXaRkfj" crossorigin="anonymous"></script>
      <script src="https://cdn.jsdelivr.net/npm/popper.js@1.16.0/dist/umd/popper.min.js" integrity="sha384-Q6E9RHvbIyZFJoft+2mJbHaEWldlvI9IOYy5n3zV9zzTtmI3UksdQRVvoxMfooAo" crossorigin="anonymous"></script>
      <script src="https://stackpath.bootstrapcdn.com/bootstrap/4.5.0/js/bootstrap.min.js" integrity="sha384-OgVRvuATP1z7JjHLkuOU7Xw704+h835Lr+6QL9UvYjZE3Ipu6Tp75j7Bh/kR0JKI" crossorigin="anonymous"></script>
      <!-- Mathjax -->
      <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
      <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
      <script>
         /* Bootstrap styles to tables */
         function bootstrapStylePandocTables() {
         $('tr.header').parent('thead').parent('table').addClass('table table-condensed'); }
         $(document).ready(function () { bootstrapStylePandocTables(); });
         /* Adjust the height when click the toc */
         var shiftWindow = function() { scrollBy(0, -60) };
         window.addEventListener("hashchange", shiftWindow);
         function load() { if (window.location.hash) shiftWindow(); }
      </script>
   </body>
</html>
