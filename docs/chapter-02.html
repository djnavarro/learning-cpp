<!doctype html>
<html>
   <head>
      <meta charset="utf-8">
      <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
      <meta name="generator" content="pandoc">
      
      
      <title>2: Working with strings and string views</title>
      <!-- Bootstrap -->
      <link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.5.0/css/bootstrap.min.css" integrity="sha384-9aIt2nRpC12Uk9gS9baDl411NQApFmC26EwAOH8WgZl5MYYxFfc+NcPb1dKGj7Sk" crossorigin="anonymous">
      <!-- Font-awesome -->
      <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css">
      <!-- Styles -->
      <link rel="stylesheet" href="style.css">
         </head>
   <body>
            <div class="container">
         <h1 class="title">2: Working with strings and string views</h1>
                  <div class="row">
            <div class="col-xl-10"><p><a href="index.html">Back to top</a></p>
<h2 id="c-style-strings">C-style strings</h2>
<p>The chapter begins with a discussion of strings in C. I understand why the book does this, but C-style strings are terrible and I want to make it a life goal never to use them again. In C, a string is literally an array of characters with a special <code>NUL</code> character (written <code>'\0'</code>) occupying the final slot. The string <code>"danielle"</code> is nothing more than a character array with values <code>{'d', 'a', 'n', 'i', 'e', 'l', 'l', 'e', '\0'}</code>. It’s “fine”, but only in the everything-is-on-fire-dog-holding-a-cup-of-coffee-saying-this-is-fine sense of the term. It’s especially horrible because the nul-terminator character is not included in the length of the string, and so you have to keep remembering that the length of every string is always +1 character longer than what it looks like. This leads to annoying code like this:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true"></a><span class="co">// append-c-strings.cpp</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true"></a><span class="pp">#include </span><span class="im">&lt;iostream&gt;</span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true"></a><span class="pp">#include </span><span class="im">&lt;cstring&gt;</span></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true"></a></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true"></a><span class="dt">char</span>* paste_strings(<span class="at">const</span> <span class="dt">char</span>* str1, <span class="at">const</span> <span class="dt">char</span>* str2, <span class="at">const</span> <span class="dt">char</span>* str3) {</span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true"></a>    <span class="at">const</span> <span class="dt">unsigned</span> <span class="dt">long</span> len1 { <span class="bu">std::</span>strlen(str1) };</span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true"></a>    <span class="at">const</span> <span class="dt">unsigned</span> <span class="dt">long</span> len2 { <span class="bu">std::</span>strlen(str2) };</span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true"></a>    <span class="at">const</span> <span class="dt">unsigned</span> <span class="dt">long</span> len3 { <span class="bu">std::</span>strlen(str3) };</span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true"></a>    <span class="dt">char</span>* out { <span class="kw">new</span> <span class="dt">char</span>[len1 + len2 + len3 + <span class="dv">1</span>] }; </span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true"></a>    <span class="bu">std::</span>strcpy(out, str1);</span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true"></a>    <span class="bu">std::</span>strcat(out, str2);</span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true"></a>    <span class="bu">std::</span>strcat(out, str3);</span>
<span id="cb1-13"><a href="#cb1-13" aria-hidden="true"></a>    <span class="cf">return</span> out;</span>
<span id="cb1-14"><a href="#cb1-14" aria-hidden="true"></a>}</span>
<span id="cb1-15"><a href="#cb1-15" aria-hidden="true"></a></span>
<span id="cb1-16"><a href="#cb1-16" aria-hidden="true"></a><span class="dt">int</span> main() {</span>
<span id="cb1-17"><a href="#cb1-17" aria-hidden="true"></a>    <span class="bu">std::</span>cout &lt;&lt; paste_strings(<span class="st">&quot;I&quot;</span>, <span class="st">&quot;hate&quot;</span>, <span class="st">&quot;this&quot;</span>) &lt;&lt; <span class="bu">std::</span>endl;</span>
<span id="cb1-18"><a href="#cb1-18" aria-hidden="true"></a>    <span class="cf">return</span> <span class="dv">0</span>;</span>
<span id="cb1-19"><a href="#cb1-19" aria-hidden="true"></a>}</span></code></pre></div>
<pre><code>Ihatethis</code></pre>
<p>I really, really do.</p>
<h2 id="string-literals">String literals</h2>
<p>Next the book turns to string literals. It starts by defining terms: the terms “string literal” just refers to the actual string value itself, rather than the variable. So <code>"cat"</code> is a string literal.</p>
<h3 id="literal-pooling">Literal pooling</h3>
<p>String literals pose different issues for languages than other kinds of literals because there’s an incredibly large number of possible string literals, and a single string literal can be quite large. C++ (much like R, actually) does the smart thing from a memory perspective by having <strong>literal pooling</strong>. String literals are stored in read-only memory, which allows the compiler to optimise memory usage: every use of the <code>"cat"</code> string literal (or a string literal containing the entire Treaty of Westphalia) is treated as a reference to the same location in memory. That way you can use the same string over and over without wasting memory.</p>
<p>That all makes sense but this is where things become tricky. You can technically assign a string literal to a variable but string literal pooling produces weirdness. Formally a string literal of length <span class="math inline">\(n\)</span> is an array of <span class="math inline">\(n\)</span> <code>const char</code> types, but (for backward compatibility, apparently) the compiler doesn’t enforce the implicit <code>const</code> in this context:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true"></a><span class="dt">char</span>* ptr { <span class="st">&quot;cat&quot;</span> }; <span class="co">// string literal is assigned to a variable</span></span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true"></a>ptr[<span class="dv">1</span>] = <span class="st">&quot;o&quot;</span>;        <span class="co">// the behaviour here is undefined</span></span></code></pre></div>
<p>A slightly safer thing to do here is to explicitly use the <code>const</code> keyword. In this case, the compiler will explicitly recognise that we’re trying to modify a <code>const</code> and throws an error:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true"></a><span class="at">const</span> <span class="dt">char</span>* ptr { <span class="st">&quot;cat&quot;</span> }; <span class="co">// string literal is assigned to a variable</span></span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true"></a>ptr[<span class="dv">1</span>] = <span class="st">&quot;o&quot;</span>;              <span class="co">// compiler throws error because you can&#39;t change a const</span></span></code></pre></div>
<p>The book has a few other details here, but I’m skipping them for now.</p>
<h3 id="escaping-in-string-literals">Escaping in string literals</h3>
<p>As with most languages, string literals in C++ include escape sequences as use <code>\</code> as the way to escaping special characters. The book treats this as assumed knowledge, which probably makes sense becaus this isn’t an introductory book and you’re expected to have some prior coding experience before attempting to read it. But for what it’s worth:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true"></a><span class="co">// string-escapes.cpp</span></span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true"></a><span class="pp">#include </span><span class="im">&lt;iostream&gt;</span></span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true"></a></span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true"></a><span class="dt">int</span> main() {</span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true"></a>    <span class="at">const</span> <span class="dt">char</span>* str { <span class="st">&quot;Dear world,</span><span class="sc">\n</span><span class="st">I should like to say </span><span class="sc">\&quot;</span><span class="st">hello</span><span class="sc">\&quot;</span><span class="st">.&quot;</span> };</span>
<span id="cb5-6"><a href="#cb5-6" aria-hidden="true"></a>    <span class="bu">std::</span>cout &lt;&lt; str &lt;&lt; <span class="bu">std::</span>endl;</span>
<span id="cb5-7"><a href="#cb5-7" aria-hidden="true"></a>    <span class="cf">return</span> <span class="dv">0</span>;</span>
<span id="cb5-8"><a href="#cb5-8" aria-hidden="true"></a>}</span></code></pre></div>
<pre><code>Dear world,
I should like to say &quot;hello&quot;.</code></pre>
<h3 id="raw-string-literals">Raw string literals</h3>
<p>To make life a little easier, C++ also supports <strong>raw string literals</strong>, which do not support escape sequences and do not require escaping of quote marks. To open a raw string literal use <code>R"(</code>, and to close it use <code>)"</code>. Naturally, you cannot construct a raw string literal that actually contains <code>)"</code> as part of the string using this syntax. You can, however, include line breaks by literally typing “enter” when specifying the string. So, ugly as it is, this works:</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true"></a><span class="co">// raw-string-literal.cpp</span></span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true"></a><span class="pp">#include </span><span class="im">&lt;iostream&gt;</span></span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true"></a></span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true"></a><span class="dt">int</span> main() {</span>
<span id="cb7-5"><a href="#cb7-5" aria-hidden="true"></a>    <span class="at">const</span> <span class="dt">char</span>* str { <span class="st">R&quot;(Dear world,</span></span>
<span id="cb7-6"><a href="#cb7-6" aria-hidden="true"></a><span class="st">I too would like to say &quot;hello&quot;.)&quot;</span> };</span>
<span id="cb7-7"><a href="#cb7-7" aria-hidden="true"></a>    <span class="bu">std::</span>cout &lt;&lt; str &lt;&lt; <span class="bu">std::</span>endl;</span>
<span id="cb7-8"><a href="#cb7-8" aria-hidden="true"></a>    <span class="cf">return</span> <span class="dv">0</span>;</span>
<span id="cb7-9"><a href="#cb7-9" aria-hidden="true"></a>}</span></code></pre></div>
<pre><code>Dear world,
I too would like to say &quot;hello&quot;.</code></pre>
<p>Finally, yes, C++ does support an extended raw string literal syntax in pretty much exactly the way you’d hope, where you can adopt a user defined sequence to signal the opening and closing of the string. For instance, to use <code>**</code> as the delimiter for an extended raw string literal corresponding to <code>"cat"</code>, I’d write <code>R"**(cat)**"</code>. It looks clunky in this case, but it’s super handy for regular expressions and various other situations. A simple example:</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true"></a><span class="co">// extended-raw-string-literal.cpp</span></span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true"></a><span class="pp">#include </span><span class="im">&lt;iostream&gt;</span></span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true"></a></span>
<span id="cb9-4"><a href="#cb9-4" aria-hidden="true"></a><span class="dt">int</span> main() {</span>
<span id="cb9-5"><a href="#cb9-5" aria-hidden="true"></a>    <span class="at">const</span> <span class="dt">char</span>* str1 { <span class="st">R&quot;**(Raw string literal containing &quot;))**&quot;</span>};</span>
<span id="cb9-6"><a href="#cb9-6" aria-hidden="true"></a>    <span class="at">const</span> <span class="dt">char</span>* str2 { <span class="st">R&quot;%%(Raw string literal containing **)%%&quot;</span>};</span>
<span id="cb9-7"><a href="#cb9-7" aria-hidden="true"></a>    <span class="bu">std::</span>cout &lt;&lt; str1 &lt;&lt; <span class="bu">std::</span>endl;</span>
<span id="cb9-8"><a href="#cb9-8" aria-hidden="true"></a>    <span class="bu">std::</span>cout &lt;&lt; str2 &lt;&lt; <span class="bu">std::</span>endl;</span>
<span id="cb9-9"><a href="#cb9-9" aria-hidden="true"></a>    <span class="cf">return</span> <span class="dv">0</span>;</span>
<span id="cb9-10"><a href="#cb9-10" aria-hidden="true"></a>}</span></code></pre></div>
<pre><code>Raw string literal containing &quot;)
Raw string literal containing **</code></pre>
<h2 id="the-stdstring-class">The <code>std::string</code> class</h2>
<p>At this point the book formally introduces the <code>std::string</code> class, a vastly superior option to using C style strings in most contexts. The class is defined in <code>&lt;string&gt;</code>, and functionality belongs to the <code>std</code> namespace. C++ strings support <code>+</code> and <code>+=</code> operators for concatenation, <code>==</code> for comparison, and subsetting with <code>[</code>. Some examples of this here:</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true"></a><span class="co">// string-class-examples.cpp</span></span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true"></a><span class="pp">#include </span><span class="im">&lt;iostream&gt;</span></span>
<span id="cb11-3"><a href="#cb11-3" aria-hidden="true"></a><span class="pp">#include </span><span class="im">&lt;string&gt;</span></span>
<span id="cb11-4"><a href="#cb11-4" aria-hidden="true"></a></span>
<span id="cb11-5"><a href="#cb11-5" aria-hidden="true"></a><span class="kw">using</span> <span class="kw">namespace</span> std;</span>
<span id="cb11-6"><a href="#cb11-6" aria-hidden="true"></a></span>
<span id="cb11-7"><a href="#cb11-7" aria-hidden="true"></a><span class="dt">int</span> main() {</span>
<span id="cb11-8"><a href="#cb11-8" aria-hidden="true"></a>    string a { <span class="st">&quot;owl&quot;</span> };</span>
<span id="cb11-9"><a href="#cb11-9" aria-hidden="true"></a>    string b { <span class="st">&quot;bear&quot;</span> };</span>
<span id="cb11-10"><a href="#cb11-10" aria-hidden="true"></a>    string c;</span>
<span id="cb11-11"><a href="#cb11-11" aria-hidden="true"></a></span>
<span id="cb11-12"><a href="#cb11-12" aria-hidden="true"></a>    <span class="co">// overloaded + operator for strings</span></span>
<span id="cb11-13"><a href="#cb11-13" aria-hidden="true"></a>    c = a + b;</span>
<span id="cb11-14"><a href="#cb11-14" aria-hidden="true"></a>    cout &lt;&lt; a &lt;&lt; <span class="st">&quot; + &quot;</span> &lt;&lt; b &lt;&lt; <span class="st">&quot; = &quot;</span> &lt;&lt; c &lt;&lt; endl;</span>
<span id="cb11-15"><a href="#cb11-15" aria-hidden="true"></a>    </span>
<span id="cb11-16"><a href="#cb11-16" aria-hidden="true"></a>    <span class="co">// overloaded += operator</span></span>
<span id="cb11-17"><a href="#cb11-17" aria-hidden="true"></a>    c += <span class="st">&quot; is the strangest creature&quot;</span>; </span>
<span id="cb11-18"><a href="#cb11-18" aria-hidden="true"></a>    cout &lt;&lt; c &lt;&lt; endl;</span>
<span id="cb11-19"><a href="#cb11-19" aria-hidden="true"></a></span>
<span id="cb11-20"><a href="#cb11-20" aria-hidden="true"></a>    <span class="co">// extracting elements with []</span></span>
<span id="cb11-21"><a href="#cb11-21" aria-hidden="true"></a>    cout &lt;&lt; <span class="st">&quot;the 17th character in &#39;&quot;</span> &lt;&lt; c &lt;&lt; <span class="st">&quot;&#39; is &quot;</span> &lt;&lt; c[<span class="dv">16</span>] &lt;&lt; endl; </span>
<span id="cb11-22"><a href="#cb11-22" aria-hidden="true"></a></span>
<span id="cb11-23"><a href="#cb11-23" aria-hidden="true"></a>    <span class="cf">return</span> <span class="dv">0</span>;</span>
<span id="cb11-24"><a href="#cb11-24" aria-hidden="true"></a>}</span></code></pre></div>
<pre><code>owl + bear = owlbear
owlbear is the strangest creature
the 17th character in &#39;owlbear is the strangest creature&#39; is t</code></pre>
<p>At this point the book spends quite a bit of time trying to convince C programmers that C++ strings are a better option if you need to do any string comparison, but of course I’m coming from interpreted languages like R and Python, so I’m coming to this part of the discussion already sold. I have not made any serious attempt to use C strings since 1994, and I have no intention of backsliding now. Suffice it to say logical operations on C++ strings have their usual meaning. Some silly code:</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true"></a><span class="co">// string-class-examples.cpp</span></span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true"></a><span class="pp">#include </span><span class="im">&lt;iostream&gt;</span></span>
<span id="cb13-3"><a href="#cb13-3" aria-hidden="true"></a><span class="pp">#include </span><span class="im">&lt;string&gt;</span></span>
<span id="cb13-4"><a href="#cb13-4" aria-hidden="true"></a></span>
<span id="cb13-5"><a href="#cb13-5" aria-hidden="true"></a><span class="kw">using</span> <span class="kw">namespace</span> std;</span>
<span id="cb13-6"><a href="#cb13-6" aria-hidden="true"></a></span>
<span id="cb13-7"><a href="#cb13-7" aria-hidden="true"></a><span class="dt">int</span> main() {</span>
<span id="cb13-8"><a href="#cb13-8" aria-hidden="true"></a>    string lowercase { <span class="st">&quot;owl&quot;</span> };</span>
<span id="cb13-9"><a href="#cb13-9" aria-hidden="true"></a>    string uppercase { <span class="st">&quot;OWL&quot;</span> };</span>
<span id="cb13-10"><a href="#cb13-10" aria-hidden="true"></a>    <span class="dt">bool</span> is_equal { lowercase == uppercase };</span>
<span id="cb13-11"><a href="#cb13-11" aria-hidden="true"></a>    <span class="dt">bool</span> is_lower_lower { lowercase &lt; uppercase };</span>
<span id="cb13-12"><a href="#cb13-12" aria-hidden="true"></a>    <span class="dt">bool</span> is_upper_lower { uppercase &lt; lowercase };</span>
<span id="cb13-13"><a href="#cb13-13" aria-hidden="true"></a>    cout &lt;&lt; <span class="st">&quot;is a lowercase string equal to its uppercase version? &quot;</span> &lt;&lt; is_equal &lt;&lt; endl;</span>
<span id="cb13-14"><a href="#cb13-14" aria-hidden="true"></a>    cout &lt;&lt; <span class="st">&quot;is a lowercase string &#39;less than&#39; an uppercase string? &quot;</span> &lt;&lt; is_lower_lower &lt;&lt; endl;</span>
<span id="cb13-15"><a href="#cb13-15" aria-hidden="true"></a>    cout &lt;&lt; <span class="st">&quot;so is the uppercase string &#39;less than&#39;? &quot;</span> &lt;&lt; is_upper_lower &lt;&lt; endl;</span>
<span id="cb13-16"><a href="#cb13-16" aria-hidden="true"></a>    <span class="cf">return</span> <span class="dv">0</span>;</span>
<span id="cb13-17"><a href="#cb13-17" aria-hidden="true"></a>}</span></code></pre></div>
<pre><code>is a lowercase string equal to its uppercase version? 0
is a lowercase string &#39;less than&#39; an uppercase string? 0
so is the uppercase string &#39;less than&#39;? 1</code></pre>
<p>All according to expectations, so let’s move on. C++ strings have a lot of helpful methods that make it easier to work with them. A few examples are demonstrated in this program:</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true"></a><span class="co">// string-class-handy.cpp</span></span>
<span id="cb15-2"><a href="#cb15-2" aria-hidden="true"></a><span class="pp">#include </span><span class="im">&lt;iostream&gt;</span></span>
<span id="cb15-3"><a href="#cb15-3" aria-hidden="true"></a><span class="pp">#include </span><span class="im">&lt;string&gt;</span></span>
<span id="cb15-4"><a href="#cb15-4" aria-hidden="true"></a></span>
<span id="cb15-5"><a href="#cb15-5" aria-hidden="true"></a><span class="dt">int</span> main() {</span>
<span id="cb15-6"><a href="#cb15-6" aria-hidden="true"></a>    <span class="bu">std::</span>string owlbear { <span class="st">&quot;owlbear&quot;</span> };</span>
<span id="cb15-7"><a href="#cb15-7" aria-hidden="true"></a>    <span class="bu">std::</span>string owl;</span>
<span id="cb15-8"><a href="#cb15-8" aria-hidden="true"></a>    <span class="bu">std::</span>string bear;</span>
<span id="cb15-9"><a href="#cb15-9" aria-hidden="true"></a>    <span class="dt">int</span> pos;</span>
<span id="cb15-10"><a href="#cb15-10" aria-hidden="true"></a></span>
<span id="cb15-11"><a href="#cb15-11" aria-hidden="true"></a>    <span class="co">// these methods don&#39;t change the value of owlbear</span></span>
<span id="cb15-12"><a href="#cb15-12" aria-hidden="true"></a>    owl = owlbear.substr(<span class="dv">0</span>, <span class="dv">3</span>);  <span class="co">// .substr(pos, len)</span></span>
<span id="cb15-13"><a href="#cb15-13" aria-hidden="true"></a>    bear = owlbear.substr(<span class="dv">3</span>, <span class="dv">4</span>);</span>
<span id="cb15-14"><a href="#cb15-14" aria-hidden="true"></a>    pos = owlbear.find(<span class="st">&quot;bear&quot;</span>);  <span class="co">// .find(str)</span></span>
<span id="cb15-15"><a href="#cb15-15" aria-hidden="true"></a></span>
<span id="cb15-16"><a href="#cb15-16" aria-hidden="true"></a>    <span class="bu">std::</span>cout &lt;&lt; owl &lt;&lt; <span class="st">&quot; is a substring of &quot;</span> &lt;&lt; owlbear &lt;&lt; <span class="bu">std::</span>endl;</span>
<span id="cb15-17"><a href="#cb15-17" aria-hidden="true"></a>    <span class="bu">std::</span>cout &lt;&lt; bear &lt;&lt; <span class="st">&quot; is also substring of &quot;</span> &lt;&lt; owlbear &lt;&lt; <span class="bu">std::</span>endl;</span>
<span id="cb15-18"><a href="#cb15-18" aria-hidden="true"></a>    <span class="bu">std::</span>cout &lt;&lt; <span class="st">&quot;the &quot;</span> &lt;&lt; bear &lt;&lt; <span class="st">&quot; substring starts at &quot;</span> &lt;&lt; pos &lt;&lt; <span class="bu">std::</span>endl;</span>
<span id="cb15-19"><a href="#cb15-19" aria-hidden="true"></a></span>
<span id="cb15-20"><a href="#cb15-20" aria-hidden="true"></a>    <span class="co">// this one does</span></span>
<span id="cb15-21"><a href="#cb15-21" aria-hidden="true"></a>    owlbear.replace(<span class="dv">0</span>, <span class="dv">3</span>, <span class="st">&quot;teddy&quot;</span>); <span class="co">// .replace(pos, len, str)</span></span>
<span id="cb15-22"><a href="#cb15-22" aria-hidden="true"></a>    <span class="bu">std::</span>cout &lt;&lt; <span class="st">&quot;a &quot;</span> &lt;&lt; owlbear &lt;&lt; <span class="st">&quot; is a different string&quot;</span> &lt;&lt; <span class="bu">std::</span>endl;</span>
<span id="cb15-23"><a href="#cb15-23" aria-hidden="true"></a>    <span class="cf">return</span> <span class="dv">0</span>;</span>
<span id="cb15-24"><a href="#cb15-24" aria-hidden="true"></a>}</span></code></pre></div>
<pre><code>owl is a substring of owlbear
bear is also substring of owlbear
the bear substring starts at 3
a teddybear is a different string</code></pre>
<p>Anyway. The book has a whole thing here about “class template argument deduction” (CTAD), talking about how the type of a <code>vector</code> class can be automatically inferred from the values used when initialising the variable. It’s a bit tricky in the case of strings because a string literal like <code>"cat"</code> is treated as <code>cont char*</code> by default, not <code>std::string</code>. That can lead to annoying problems when relying on CTAD for strings. Most of the time you probably want a vector of <code>std::string</code> types, not a vector of <code>const char*</code> types. The book points out that you can get around this by writing something <code>"cat"s</code>: the <code>s</code> at the end is used to specify that this string literal should give rise to <code>std::string</code> type when used for CTAD.</p>
<p>Which. Fine. But honestly, I feel like this is a situation where it makes more sense to explicitly state that the thing you want is a vector of strings. In the following code, specifying <code>vector&lt;string&gt;</code> as the type makes so much more sense than trying to save some key strokes by typing <code>vector</code> and then appending a bunch of weird <code>s</code> characters to all my string literals:</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true"></a><span class="co">// string-vectors.cpp</span></span>
<span id="cb17-2"><a href="#cb17-2" aria-hidden="true"></a><span class="pp">#include </span><span class="im">&lt;iostream&gt;</span></span>
<span id="cb17-3"><a href="#cb17-3" aria-hidden="true"></a><span class="pp">#include </span><span class="im">&lt;string&gt;</span></span>
<span id="cb17-4"><a href="#cb17-4" aria-hidden="true"></a><span class="pp">#include </span><span class="im">&lt;vector&gt;</span></span>
<span id="cb17-5"><a href="#cb17-5" aria-hidden="true"></a></span>
<span id="cb17-6"><a href="#cb17-6" aria-hidden="true"></a><span class="kw">using</span> <span class="kw">namespace</span> std;</span>
<span id="cb17-7"><a href="#cb17-7" aria-hidden="true"></a></span>
<span id="cb17-8"><a href="#cb17-8" aria-hidden="true"></a><span class="dt">int</span> main() {</span>
<span id="cb17-9"><a href="#cb17-9" aria-hidden="true"></a>    vector&lt;string&gt; names { <span class="st">&quot;Dani&quot;</span>, <span class="st">&quot;Danielle&quot;</span>, <span class="st">&quot;Daniela&quot;</span> };</span>
<span id="cb17-10"><a href="#cb17-10" aria-hidden="true"></a>    <span class="cf">for</span> (string name : names) {</span>
<span id="cb17-11"><a href="#cb17-11" aria-hidden="true"></a>        cout &lt;&lt; name &lt;&lt; <span class="st">&quot; &quot;</span>;</span>
<span id="cb17-12"><a href="#cb17-12" aria-hidden="true"></a>    }</span>
<span id="cb17-13"><a href="#cb17-13" aria-hidden="true"></a>    cout &lt;&lt; endl;</span>
<span id="cb17-14"><a href="#cb17-14" aria-hidden="true"></a>    <span class="cf">return</span> <span class="dv">0</span>;</span>
<span id="cb17-15"><a href="#cb17-15" aria-hidden="true"></a>}</span></code></pre></div>
<pre><code>Dani Danielle Daniela </code></pre>
<p>Anyway.</p>
<h2 id="converting-numerics-to-strings">Converting numerics to strings</h2>
<p>Conversion from strings to numeric and vice versa requires a little thought. First, let’s consider “high level” conversion from string to numeric types. We can do that with the <code>to_string()</code> function exposed by <code>&lt;string&gt;</code>. Here’s an example:</p>
<div class="sourceCode" id="cb19"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb19-1"><a href="#cb19-1" aria-hidden="true"></a><span class="co">// string-to-numeric.cpp</span></span>
<span id="cb19-2"><a href="#cb19-2" aria-hidden="true"></a><span class="pp">#include </span><span class="im">&lt;iostream&gt;</span></span>
<span id="cb19-3"><a href="#cb19-3" aria-hidden="true"></a><span class="pp">#include </span><span class="im">&lt;string&gt;</span></span>
<span id="cb19-4"><a href="#cb19-4" aria-hidden="true"></a></span>
<span id="cb19-5"><a href="#cb19-5" aria-hidden="true"></a><span class="dt">int</span> main () {</span>
<span id="cb19-6"><a href="#cb19-6" aria-hidden="true"></a></span>
<span id="cb19-7"><a href="#cb19-7" aria-hidden="true"></a>    <span class="dt">double</span> dbl1 { <span class="fl">32.1435</span> };</span>
<span id="cb19-8"><a href="#cb19-8" aria-hidden="true"></a>    <span class="dt">double</span> dbl2 { <span class="fl">64.3452</span> };</span>
<span id="cb19-9"><a href="#cb19-9" aria-hidden="true"></a>    <span class="dt">int</span> int3 { <span class="dv">145</span> };</span>
<span id="cb19-10"><a href="#cb19-10" aria-hidden="true"></a>    <span class="dt">int</span> int4 { <span class="dv">522</span> };</span>
<span id="cb19-11"><a href="#cb19-11" aria-hidden="true"></a>    <span class="bu">std::</span>string str1;</span>
<span id="cb19-12"><a href="#cb19-12" aria-hidden="true"></a>    <span class="bu">std::</span>string str2;</span>
<span id="cb19-13"><a href="#cb19-13" aria-hidden="true"></a>    <span class="bu">std::</span>string str3;</span>
<span id="cb19-14"><a href="#cb19-14" aria-hidden="true"></a>    <span class="bu">std::</span>string str4;</span>
<span id="cb19-15"><a href="#cb19-15" aria-hidden="true"></a></span>
<span id="cb19-16"><a href="#cb19-16" aria-hidden="true"></a>    str1 = <span class="bu">std::</span>to_string(dbl1);</span>
<span id="cb19-17"><a href="#cb19-17" aria-hidden="true"></a>    str2 = <span class="bu">std::</span>to_string(dbl2);</span>
<span id="cb19-18"><a href="#cb19-18" aria-hidden="true"></a>    str3 = <span class="bu">std::</span>to_string(int3);</span>
<span id="cb19-19"><a href="#cb19-19" aria-hidden="true"></a>    str4 = <span class="bu">std::</span>to_string(int4);</span>
<span id="cb19-20"><a href="#cb19-20" aria-hidden="true"></a></span>
<span id="cb19-21"><a href="#cb19-21" aria-hidden="true"></a>    <span class="bu">std::</span>cout &lt;&lt; <span class="st">&quot;+ operator on double: &quot;</span> &lt;&lt; dbl1 + dbl2 &lt;&lt; <span class="bu">std::</span>endl;</span>
<span id="cb19-22"><a href="#cb19-22" aria-hidden="true"></a>    <span class="bu">std::</span>cout &lt;&lt; <span class="st">&quot;+ operator on string: &quot;</span> &lt;&lt; str1 + str2 &lt;&lt; <span class="bu">std::</span>endl;</span>
<span id="cb19-23"><a href="#cb19-23" aria-hidden="true"></a>    <span class="bu">std::</span>cout &lt;&lt; <span class="st">&quot;+ operator on integers: &quot;</span> &lt;&lt; int3 + int4 &lt;&lt; <span class="bu">std::</span>endl;</span>
<span id="cb19-24"><a href="#cb19-24" aria-hidden="true"></a>    <span class="bu">std::</span>cout &lt;&lt; <span class="st">&quot;+ operator on string: &quot;</span> &lt;&lt; str3 + str4 &lt;&lt; <span class="bu">std::</span>endl;</span>
<span id="cb19-25"><a href="#cb19-25" aria-hidden="true"></a></span>
<span id="cb19-26"><a href="#cb19-26" aria-hidden="true"></a>    <span class="cf">return</span> <span class="dv">0</span>;</span>
<span id="cb19-27"><a href="#cb19-27" aria-hidden="true"></a>}</span></code></pre></div>
<pre><code>+ operator on double: 96.4887
+ operator on string: 32.14350064.345200
+ operator on integers: 667
+ operator on string: 145522</code></pre>
<h2 id="converting-strings-to-numerics">Converting strings to numerics</h2>
<p>To convert a string to a numeric type, you call one of the "sto*" functions. There’s a naming convention for these functions reflecting the specific output type you want. It’s comprehensible, albeit only barely and the names are pointlessly terse. The sheer effort that programmers will go to sometimes to write code that saves a few keystrokes at the cost of making the code look like utter gibberish is remarkable. Anyway:</p>
<ul>
<li><code>stoi()</code> returns an <code>int</code></li>
<li><code>stol()</code> returns a <code>long</code></li>
<li><code>stoul()</code> returns an <code>unsigned long</code></li>
<li><code>stoll()</code> returns a <code>long long</code></li>
<li><code>stoull()</code> returns an <code>unsigned long long</code></li>
<li><code>stof()</code> returns a <code>float</code></li>
<li><code>stod()</code> returns a <code>double</code></li>
<li><code>stold()</code> returns a <code>long double</code></li>
</ul>
<p>Peeking ahead a little, I have a suspicion this is something where templates come in handy? But I’m not yet ready for templates so whatever. The key thing for now is that in practice I’d be most likely to need <code>stoi()</code> or <code>stod()</code>, since integers and doubles are my go-to numeric types.</p>
<p>In any case, all of these functions have identical arguments, so for what it’s worth here’s the function signature for <code>stoi()</code>:</p>
<div class="sourceCode" id="cb21"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb21-1"><a href="#cb21-1" aria-hidden="true"></a><span class="dt">int</span> stoi(<span class="at">const</span> string&amp; str, <span class="dt">size_t</span> *idx = <span class="dv">0</span>, <span class="dt">int</span> base = <span class="dv">10</span>);</span></code></pre></div>
<ul>
<li>The first argument <code>str</code> is the to-be-converted string</li>
<li>The second (optional) argument <code>*idk</code> is a pointer that takes the index of the first non-parsed character in the string</li>
<li>The third (optional) argument <code>base</code> is an integer specifying the mathematical base (defaults to 10, but you could get hexadecimal numbers by setting <code>base = 16</code>).</li>
</ul>
<p>When these functions are called, there are a couple of things to note. First, any leading whitespace in the string is ignored. Second, the functions have both a return value (the numeric value) and a side effect (the index of the first nonparsed character is updated). Inelegant as that feels, it can be handy. Here’s a slighly tweaked version of the example given in the book that illustrates the point:</p>
<div class="sourceCode" id="cb22"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb22-1"><a href="#cb22-1" aria-hidden="true"></a><span class="co">// stoi.cpp</span></span>
<span id="cb22-2"><a href="#cb22-2" aria-hidden="true"></a><span class="pp">#include </span><span class="im">&lt;iostream&gt;</span></span>
<span id="cb22-3"><a href="#cb22-3" aria-hidden="true"></a><span class="pp">#include </span><span class="im">&lt;string&gt;</span></span>
<span id="cb22-4"><a href="#cb22-4" aria-hidden="true"></a></span>
<span id="cb22-5"><a href="#cb22-5" aria-hidden="true"></a><span class="dt">int</span> main() {</span>
<span id="cb22-6"><a href="#cb22-6" aria-hidden="true"></a>    <span class="bu">std::</span>string monetary_string {}, monetary_unit {};</span>
<span id="cb22-7"><a href="#cb22-7" aria-hidden="true"></a>    <span class="dt">size_t</span> index { <span class="dv">0</span> };</span>
<span id="cb22-8"><a href="#cb22-8" aria-hidden="true"></a>    <span class="dt">int</span> monetary_value { <span class="dv">0</span> };</span>
<span id="cb22-9"><a href="#cb22-9" aria-hidden="true"></a></span>
<span id="cb22-10"><a href="#cb22-10" aria-hidden="true"></a>    <span class="co">// number is stored as the return value, index is modified</span></span>
<span id="cb22-11"><a href="#cb22-11" aria-hidden="true"></a>    monetary_string = <span class="st">&quot;    123AUD&quot;</span>;</span>
<span id="cb22-12"><a href="#cb22-12" aria-hidden="true"></a>    monetary_value = <span class="bu">std::</span>stoi(monetary_string, &amp;index);</span>
<span id="cb22-13"><a href="#cb22-13" aria-hidden="true"></a>    monetary_unit = monetary_string.substr(index, <span class="dv">3</span>);</span>
<span id="cb22-14"><a href="#cb22-14" aria-hidden="true"></a></span>
<span id="cb22-15"><a href="#cb22-15" aria-hidden="true"></a>    <span class="bu">std::</span>cout &lt;&lt; <span class="st">&quot;value: &quot;</span> &lt;&lt; monetary_value &lt;&lt; <span class="st">&quot;, unit: &quot;</span> &lt;&lt; monetary_unit &lt;&lt; <span class="bu">std::</span>endl;</span>
<span id="cb22-16"><a href="#cb22-16" aria-hidden="true"></a>    <span class="cf">return</span> <span class="dv">0</span>;</span>
<span id="cb22-17"><a href="#cb22-17" aria-hidden="true"></a>}</span></code></pre></div>
<pre><code>value: 123, unit: AUD</code></pre>
<h2 id="low-level-conversions">Low level conversions</h2>
<p>At this point the book also discusses lower level functions to convert between strings and numeric values. The lower level functions require more care but can be much much faster. For now, I’m going to skip this section and leave it as a promissory note to myself that I may want to return to this one day.</p>
<h2 id="the-stdstring_view-class">The <code>std::string_view</code> class</h2>
<p>Until this very moment in my life I had not heard of C++ string views. Not because they aren’t valuable, but, rather, because they were introduced only in C++17. Most R code that calls C++ uses C++11, and most other projects I’ve interacted with are also on older C++ versions. The problem solved by string views is to provide a read-only view of a string (it doesn’t make copies) and as such is pretty handy when defining functions that take a read-only string as input.</p>
<p>The book uses the example of a function that extracts a file extension:</p>
<div class="sourceCode" id="cb24"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb24-1"><a href="#cb24-1" aria-hidden="true"></a><span class="co">// file-extension.cpp</span></span>
<span id="cb24-2"><a href="#cb24-2" aria-hidden="true"></a><span class="pp">#include </span><span class="im">&lt;iostream&gt;</span></span>
<span id="cb24-3"><a href="#cb24-3" aria-hidden="true"></a><span class="pp">#include </span><span class="im">&lt;string&gt;</span></span>
<span id="cb24-4"><a href="#cb24-4" aria-hidden="true"></a></span>
<span id="cb24-5"><a href="#cb24-5" aria-hidden="true"></a><span class="bu">std::</span>string_view file_extension(<span class="bu">std::</span>string_view file_name) {</span>
<span id="cb24-6"><a href="#cb24-6" aria-hidden="true"></a>    <span class="cf">return</span> file_name.substr(file_name.rfind(<span class="ch">&#39;.&#39;</span>));</span>
<span id="cb24-7"><a href="#cb24-7" aria-hidden="true"></a>}</span>
<span id="cb24-8"><a href="#cb24-8" aria-hidden="true"></a></span>
<span id="cb24-9"><a href="#cb24-9" aria-hidden="true"></a><span class="dt">int</span> main() {</span>
<span id="cb24-10"><a href="#cb24-10" aria-hidden="true"></a>    <span class="co">// same content, different types</span></span>
<span id="cb24-11"><a href="#cb24-11" aria-hidden="true"></a>    <span class="bu">std::</span>string file1 { <span class="st">R&quot;(c:\temp\badly named file.txt)&quot;</span> }; </span>
<span id="cb24-12"><a href="#cb24-12" aria-hidden="true"></a>    <span class="at">const</span> <span class="dt">char</span>* file2 { <span class="st">R&quot;(c:\temp\badly named file.txt)&quot;</span> }; </span>
<span id="cb24-13"><a href="#cb24-13" aria-hidden="true"></a></span>
<span id="cb24-14"><a href="#cb24-14" aria-hidden="true"></a>    <span class="co">// works for C++ strings, C strings, and string literals</span></span>
<span id="cb24-15"><a href="#cb24-15" aria-hidden="true"></a>    <span class="bu">std::</span>cout &lt;&lt; file_extension(file1) &lt;&lt; <span class="bu">std::</span>endl;</span>
<span id="cb24-16"><a href="#cb24-16" aria-hidden="true"></a>    <span class="bu">std::</span>cout &lt;&lt; file_extension(file2) &lt;&lt; <span class="bu">std::</span>endl;</span>
<span id="cb24-17"><a href="#cb24-17" aria-hidden="true"></a>    <span class="bu">std::</span>cout &lt;&lt; file_extension(<span class="st">R&quot;(c:\temp\badly named file.txt)&quot;</span>) &lt;&lt; <span class="bu">std::</span>endl;</span>
<span id="cb24-18"><a href="#cb24-18" aria-hidden="true"></a>    <span class="cf">return</span> <span class="dv">0</span>;</span>
<span id="cb24-19"><a href="#cb24-19" aria-hidden="true"></a>}</span></code></pre></div>
<pre><code>.txt
.txt
.txt</code></pre>
<p>The thing to keep in mind is that you can’t implicitly convert a string view to a string. You have to construct it explicitly. You can do this by calling the <code>.data()</code> method for a string view, or by explicit construction:</p>
<div class="sourceCode" id="cb26"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb26-1"><a href="#cb26-1" aria-hidden="true"></a><span class="co">// file-extension-2.cpp</span></span>
<span id="cb26-2"><a href="#cb26-2" aria-hidden="true"></a><span class="pp">#include </span><span class="im">&lt;iostream&gt;</span></span>
<span id="cb26-3"><a href="#cb26-3" aria-hidden="true"></a><span class="pp">#include </span><span class="im">&lt;string&gt;</span></span>
<span id="cb26-4"><a href="#cb26-4" aria-hidden="true"></a></span>
<span id="cb26-5"><a href="#cb26-5" aria-hidden="true"></a><span class="bu">std::</span>string_view file_extension(<span class="bu">std::</span>string_view file_name) {</span>
<span id="cb26-6"><a href="#cb26-6" aria-hidden="true"></a>    <span class="cf">return</span> file_name.substr(file_name.rfind(<span class="ch">&#39;.&#39;</span>));</span>
<span id="cb26-7"><a href="#cb26-7" aria-hidden="true"></a>}</span>
<span id="cb26-8"><a href="#cb26-8" aria-hidden="true"></a></span>
<span id="cb26-9"><a href="#cb26-9" aria-hidden="true"></a><span class="dt">void</span> print_string(<span class="at">const</span> <span class="bu">std::</span>string&amp; str) {</span>
<span id="cb26-10"><a href="#cb26-10" aria-hidden="true"></a>    <span class="bu">std::</span>cout &lt;&lt; str &lt;&lt; <span class="bu">std::</span>endl;</span>
<span id="cb26-11"><a href="#cb26-11" aria-hidden="true"></a>}</span>
<span id="cb26-12"><a href="#cb26-12" aria-hidden="true"></a></span>
<span id="cb26-13"><a href="#cb26-13" aria-hidden="true"></a><span class="dt">int</span> main() {</span>
<span id="cb26-14"><a href="#cb26-14" aria-hidden="true"></a>    <span class="bu">std::</span>string file { <span class="st">R&quot;(c:\temp\badly named file.txt)&quot;</span> }; </span>
<span id="cb26-15"><a href="#cb26-15" aria-hidden="true"></a></span>
<span id="cb26-16"><a href="#cb26-16" aria-hidden="true"></a>    <span class="co">// print_string(file_extension(file));              // fails</span></span>
<span id="cb26-17"><a href="#cb26-17" aria-hidden="true"></a>    print_string(file_extension(file).data());          <span class="co">// works</span></span>
<span id="cb26-18"><a href="#cb26-18" aria-hidden="true"></a>    print_string(<span class="bu">std::</span>string { file_extension(file) }); <span class="co">// works</span></span>
<span id="cb26-19"><a href="#cb26-19" aria-hidden="true"></a></span>
<span id="cb26-20"><a href="#cb26-20" aria-hidden="true"></a>    <span class="cf">return</span> <span class="dv">0</span>;</span>
<span id="cb26-21"><a href="#cb26-21" aria-hidden="true"></a>}</span></code></pre></div>
<pre><code>.txt
.txt</code></pre>
<p>I think the key message implicit in these examples is that you always want to think about precisely what you are trying to do with the text.</p>
<ul>
<li>Are you trying to pass a read-only string to a function: have it accept a string view</li>
<li>Should the return value of a function be read-only? If yes, it can return a <code>std::string_view</code>, but if it’s supposed to be modifiable then the return type you want is either <code>std::string</code> or – if a reference is preferred – <code>const std::string&amp;</code></li>
</ul>
<p>There’s also a need for care in regards to temporary strings. You don’t want to store a view of a temporary string: if the string itself goes away, so too does the view. The example usd in the book is essentially this:</p>
<div class="sourceCode" id="cb28"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb28-1"><a href="#cb28-1" aria-hidden="true"></a><span class="bu">std::</span>string s { <span class="st">&quot;Hello&quot;</span> }; </span>
<span id="cb28-2"><a href="#cb28-2" aria-hidden="true"></a><span class="bu">std::</span>string_view v { s + <span class="st">&quot; world&quot;</span> };  <span class="co">// badness!</span></span>
<span id="cb28-3"><a href="#cb28-3" aria-hidden="true"></a><span class="bu">std::</span>cout &lt;&lt; v &lt;&lt; <span class="bu">std::</span>endl;</span></code></pre></div>
<p>This is undefined behaviour, and apparently gives different results depending on the compiler and compiler settings. It took me a moment to understand where the badness is coming from. The issue here is that when <code>v</code> is initialised, a temporary string <code>s + " world"</code> is constructed, and then <code>v</code> is defined as string view of that temporary string. However, it really is a temporary string: it goes away at the end of line 2, which leaves <code>v</code> undefined (or more precisely, <code>v</code> is now a dangling pointer to a string that doesn’t exist). That is the badness.</p>
<h2 id="string-formatting">String formatting</h2>
<p>The book has a long discussion at this point about C++20 style string formatting options using the <code>format()</code> function provided by the <code>&lt;format&gt;</code> library. It looks really nice, but doesn’t seem to be supported in clang15 so I’m skipping this section. That said, I did a bit of extra reading elsewhere and the <code>&lt;fmt&gt;</code> library (external) appears to be the way you would do this properly in older versions of C++. That’s nice and all, but again I’m going to leave this as a promissory note to future me.</p>
<p><a href="index.html">Back to top</a></p></div>
            <div class="d-none d-xl-block col-xl-2 bd-toc">
               <ul class="section-nav">
                  <li class="toc-entry"><ul>
<li><a href="#c-style-strings">C-style strings</a></li>
<li><a href="#string-literals">String literals</a></li>
<li><a href="#the-stdstring-class">The <code>std::string</code> class</a></li>
<li><a href="#converting-numerics-to-strings">Converting numerics to strings</a></li>
<li><a href="#converting-strings-to-numerics">Converting strings to numerics</a></li>
<li><a href="#low-level-conversions">Low level conversions</a></li>
<li><a href="#the-stdstring_view-class">The <code>std::string_view</code> class</a></li>
<li><a href="#string-formatting">String formatting</a></li>
</ul></li>
               </ul>
            </div>
         </div>
               </div>
            <!-- JS, Popper.js, and jQuery -->
      <script src="https://code.jquery.com/jquery-3.5.1.slim.min.js" integrity="sha384-DfXdz2htPH0lsSSs5nCTpuj/zy4C+OGpamoFVy38MVBnE+IbbVYUew+OrCXaRkfj" crossorigin="anonymous"></script>
      <script src="https://cdn.jsdelivr.net/npm/popper.js@1.16.0/dist/umd/popper.min.js" integrity="sha384-Q6E9RHvbIyZFJoft+2mJbHaEWldlvI9IOYy5n3zV9zzTtmI3UksdQRVvoxMfooAo" crossorigin="anonymous"></script>
      <script src="https://stackpath.bootstrapcdn.com/bootstrap/4.5.0/js/bootstrap.min.js" integrity="sha384-OgVRvuATP1z7JjHLkuOU7Xw704+h835Lr+6QL9UvYjZE3Ipu6Tp75j7Bh/kR0JKI" crossorigin="anonymous"></script>
      <!-- Mathjax -->
      <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
      <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
      <script>
         /* Bootstrap styles to tables */
         function bootstrapStylePandocTables() {
         $('tr.header').parent('thead').parent('table').addClass('table table-condensed'); }
         $(document).ready(function () { bootstrapStylePandocTables(); });
         /* Adjust the height when click the toc */
         var shiftWindow = function() { scrollBy(0, -60) };
         window.addEventListener("hashchange", shiftWindow);
         function load() { if (window.location.hash) shiftWindow(); }
      </script>
   </body>
</html>
